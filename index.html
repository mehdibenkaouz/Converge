<!doctype html>
<html lang="it">
<head>
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0f172a">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;600;700;800&family=Sora:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <meta name="theme-color" content="#050611">

<title>Converge</title>
<!-- <script>
(function(){
  const params = new URLSearchParams(location.search);
  const hasAppParam = params.get("app") === "1";

  // TWA/PWA di solito risultano "standalone" o "fullscreen"
  const isStandalone =
    window.matchMedia("(display-mode: standalone)").matches ||
    window.matchMedia("(display-mode: fullscreen)").matches ||
    window.matchMedia("(display-mode: minimal-ui)").matches ||
    (navigator.standalone === true);

  // Se siamo in standalone, marchiamo "ok, è app"
  if (isStandalone) {
    localStorage.setItem("__converge_official", "1");
  }

  const isOfficial = localStorage.getItem("__converge_official") === "1";

  // Se è app (TWA), assicuriamoci che app=1 ci sia SEMPRE (così non ricadi nel bug)
  if (isOfficial && !hasAppParam) {
    params.set("app", "1");
    location.replace(location.pathname + "?" + params.toString() + location.hash);
    return;
  }

  // Se NON è app, blocca (web normale)
  if (!isOfficial) {
    document.documentElement.innerHTML = `
      <style>
        body{
          margin:0;height:100vh;display:flex;align-items:center;justify-content:center;
          background:#0b0c16;color:#e6e6e6;font-family:system-ui;text-align:center;padding:20px;
        }
        a{color:#8ab4ff;text-decoration:none;}
      </style>
      <div>
        <h2>Converge is available only in the official app.</h2>
        <p>Please download the app from Google Play.</p>
      </div>
    `;
  }
})();
</script> -->


<style>
:root{
    /* ===== Converge “WOW” theme (premium + playful) ===== */
    --bg-0:#050611;           /* deep space */
    --bg-1:#071b2d;           /* ocean night */
    --bg-2:#0b3a3a;           /* teal */
    --bg-3:#7cf5c5;           /* mint glow */

    --card: rgba(255,255,255,.10);
    --card-2: rgba(255,255,255,.06);

    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.65);

    --shadow: 0 22px 60px rgba(0,0,0,.55);
    --shadow-soft: 0 14px 34px rgba(0,0,0,.35);

    --board-shadow-in: inset 0 1px 0 rgba(255,255,255,.14), inset 0 -28px 60px rgba(0,0,0,.55);
    --board-border: rgba(255,255,255,.16);

    --tile-shadow: 0 18px 50px rgba(0,0,0,.45);
    --tile-shadow-soft: 0 10px 26px rgba(0,0,0,.28);

    --tile-round: 22px;
    --gap: 12px;
    --board-pad: 16px;

    --anim-move: max(calc(240ms / var(--anim-game)), 40ms);
    --anim-prebreak: max(calc(420ms / var(--anim-game)), 70ms);
    --anim-fade: max(calc(260ms / var(--anim-game)), 50ms);


    /* Pastel tiles (kept for game readability) */
    --accent-1:#ffc8ba; /* peach */
    --accent-2:#f5d4b8; /* sand */
    --accent-3:#d4f0d4; /* mint */
    --accent-4:#c8e6f5; /* sky */
    --accent-5:#dcc8f5; /* lavender */
    --accent-6:#f5c8e6; /* rose */
    --accent-7:#e6f5c8; /* pistachio */

    --glass: rgba(255,255,255,.12);
    --glass-border: rgba(255,255,255,.18);

    --ring: 0 0 0 4px rgba(124,245,197,.18), 0 0 0 1px rgba(255,255,255,.18) inset;

    --radius-xl: 26px;
    --radius-lg: 20px;
    --radius-md: 16px;

    --hue: 160deg;
    --anim-game: 1;
    --anim-fx: 1;

  }

  *{ box-sizing:border-box; }
  html, body{ width:100%; height:100%; }

  body{
    margin:0;
    font-family: "Sora", "Baloo 2", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    color: var(--text);
    min-height: 100dvh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding-top: max(clamp(12px, 2.2vw, 22px), env(safe-area-inset-top));
    padding-left: max(clamp(12px, 2.2vw, 22px), env(safe-area-inset-left));
    padding-right: max(clamp(12px, 2.2vw, 22px), env(safe-area-inset-right));
    padding-bottom: max(clamp(12px, 2.2vw, 22px), env(safe-area-inset-bottom));
    overscroll-behavior:none;
    touch-action:none;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;

    /* Base deep gradient */
    background:
      radial-gradient(1200px 800px at 10% 0%, rgba(124,245,197,.16), transparent 55%),
      radial-gradient(1000px 700px at 90% 10%, rgba(124,170,245,.14), transparent 55%),
      radial-gradient(900px 650px at 30% 100%, rgba(245,124,215,.12), transparent 60%),
      linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 45%, #04050d 100%);
    position: relative;
    overflow-x: hidden;
  }

  /* Animated aurora blobs */

  body::after{
    content:"";
    position: fixed;
    inset:-20%;
    pointer-events:none;
    z-index:0;
    filter: blur(40px) saturate(140%);
    opacity:.55;
    transform: translate3d(0,0,0);
    will-change: transform;
    mix-blend-mode: screen;
    
  }
  
  body::before{
    background:
      radial-gradient(closest-side at 25% 35%, rgba(124,245,197,.55), transparent 60%),
      radial-gradient(closest-side at 75% 30%, rgba(124,170,245,.45), transparent 62%),
      radial-gradient(closest-side at 55% 75%, rgba(245,124,215,.42), transparent 60%);
    animation: auroraA 10s ease-in-out infinite alternate;
    
  }
  body::after{
    background:
      radial-gradient(closest-side at 15% 70%, rgba(255,220,124,.20), transparent 62%),
      radial-gradient(closest-side at 85% 75%, rgba(124,245,197,.26), transparent 65%),
      radial-gradient(closest-side at 60% 15%, rgba(124,170,245,.22), transparent 64%);
    animation: auroraB 18s ease-in-out infinite alternate;
  }
  @keyframes auroraA{
    0%{ transform: translate(-2%, -1%) rotate(0deg) scale(1.05); }
    100%{ transform: translate(2%, 1%) rotate(10deg) scale(1.12); }
  }
  @keyframes auroraB{
    0%{ transform: translate(2%, 1%) rotate(-6deg) scale(1.06); }
    100%{ transform: translate(-2%, -1%) rotate(6deg) scale(1.14); }
  }

  /* mobile performance: niente aurora animata */
  html.lowgfx body::before,
  html.lowgfx body::after{
    animation: none !important;
    filter: blur(32px) saturate(120%);
    opacity: .45;
  }

  /* Subtle grain */
  .app::before{
    content:"";
    position: fixed;
    inset:0;
    pointer-events:none;
    z-index:1;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency=".9" numOctaves="3" stitchTiles="stitch"/></filter><rect width="120" height="120" filter="url(%23n)" opacity=".25"/></svg>');
    opacity:.12;
    mix-blend-mode: overlay;
  }

  .app{
    width: min(980px, 100%);
    display: grid;
    gap: 14px;
    position: relative;
    z-index:2;
  }

.app > *{
  position: relative;
  z-index: 1;
}


/* ===== Ultra thin radial lasers with glow ===== */
.app::after{
  content:"";
  position:absolute;
  left:50%;
  top:50%;
  width:240vmax;
  height:240vmax;
  transform: translate(-50%, -50%) rotate(0deg);
  transform-origin:center;

  pointer-events:none;
  z-index:0;

  /* Layer 1: ultra thin sharp lines */
  background:
    repeating-conic-gradient(
      from 0deg,
      rgba(255, 255, 255, 0.185) 0deg 0.6deg,
      transparent 0.6deg 14deg
    );

  mix-blend-mode: screen;
  opacity:.65;

  animation: laserSpin 370s linear infinite;

  will-change: transform;
  backface-visibility:hidden;
}

@keyframes laserSpin{
  0%   { transform: translate(-50%, -50%) rotate(0deg); }
  100% { transform: translate(-50%, -50%) rotate(360deg); }
}


html.lowgfx .app::after{
  animation:none !important;
  opacity:.25;
}


  /* ===== Topbar (premium glass) ===== */
  .topbar{
    display:flex;
    flex-direction:column;
    align-items:stretch;
    gap: 12px;
    padding: 14px 16px;
    border-radius: var(--radius-xl);
    position:relative;
    background: transparent;
    border: 0px solid rgba(255,255,255,.14);
    overflow:hidden;
  }


  .title{
    display:flex;
    flex-direction:column;
    gap: 4px;
    min-width: 190px;
  }
  .title h1{
    margin:0;
    font-family: "Baloo 2", "Sora", ui-sans-serif, system-ui;
    font-weight: 800;
    letter-spacing: .3px;
    font-size: clamp(37px, 1.2vw, 20px);
    line-height: 1;
    background: linear-gradient(90deg, rgba(124,245,197,.95), rgba(124,170,245,.95), rgba(245,124,215,.92));
    -webkit-background-clip:text;
    background-clip:text;
    color: transparent;
    text-shadow: 0 10px 30px rgba(0,0,0,.25);
  }
  .sub{
    font-weight: 600;
    font-size: 13.5px;
    color: rgba(255,255,255,.70);
  }
  .userbadge{
    font-weight: 700;
    font-size: 12.5px;
    color: rgba(255,255,255,.78);
    background: rgba(0,0,0,.22);
    border: 1px solid rgba(255,255,255,.12);
    padding: 7px 10px;
    border-radius: 999px;
    width: fit-content;
    box-shadow: 0 10px 22px rgba(0,0,0,.25);
  }

  .userbox{
    display:flex;
    align-items:center;
    justify-content:center;
    gap: 10px;
  }
  .iconbtn{
    width: 50px;
    height: 50px;
    border-radius: 30px;
    border: 0px solid rgba(255,255,255,.14);
    background:
      radial-gradient(120% 120% at 20% 20%, rgba(255,255,255,.20), rgba(255,255,255,.06)),
      rgba(0,0,0,.18);
    color: rgba(255,255,255,.90);
    box-shadow: 0 12px 26px rgba(0,0,0,.35);
    cursor:pointer;
    transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    user-select:none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    font-size: 18px;
    line-height: 1;
  }
  .iconbtn:hover{ transform: translateY(-1px); filter: brightness(1.05); }
  .iconbtn:active{ transform: translateY(0px) scale(.98); box-shadow: 0 8px 18px rgba(0,0,0,.30); }
  .iconbtn:focus-visible{ outline: none; box-shadow: var(--shadow-soft), var(--ring); }
  /* --- Mobile header layout blocks --- */
  .iconbtn{
    padding: 0;
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    line-height: 1;
  }

  .topbar-head{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap: 12px;
  }
  .topbar-icons{
    display:flex;
    align-items:center;
    gap: 10px;
    flex-shrink:0;
  }

  .hud{
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    align-items: stretch;
  }

  .hud-reward,
  .reward-status,
  .hud-size{
    grid-column: span 3;
  }

  .hud-card{
    padding: 10px 12px;
    border-radius: 18px;
    background: rgba(0,0,0,.22);
    border: 1px solid rgba(255,255,255,.12);
    box-shadow: 0 12px 22px rgba(0,0,0,.25);
    display:flex;
    align-items:baseline;
    gap: 10px;
    min-height: 44px;
  }
  .hud-label{
    font-weight: 900;
    font-size: 12px;
    letter-spacing: .8px;
    text-transform: uppercase;
    opacity: .85;
  }
  .hud-value{
    font-weight: 900;
    font-size: 18px;
  }

  .hud-reward{
    min-height: 44px;
    border-radius: 18px;
    padding: 10px 12px;
    display:flex;
    align-items:center;
    justify-content:center;
    gap: 10px;
  }



  .hud-btn:active,
  .iconbtn:active{
    transform: scale(.92);
  }

  .topbar-actions{
    display:flex;
    flex-wrap:wrap;
    gap: 10px;
    justify-content:flex-end;
    align-items:center;
  }

  .reward-status{
    width: 100%;
    margin-top: 2px;
  }

  .levelbar{ display:none; }

  @media (max-width: 520px){
    .sub{ display:none; }

    .title{
      min-width: 0;
      align-items:flex-start;
      text-align:left;
    }

    .topbar-actions{ display:none; }

    /* HUD grid like the mock */
    .hud{
      display:grid;
      grid-template-columns: 1fr 1fr auto;
      grid-template-areas:
        "score best reward"
        "score moves reward";
      align-items:stretch;
    }
    .hud-score{ grid-area: score; }
    .hud-best{ grid-area: best; }
    .hud-moves{ grid-area: moves; }
    .hud-reward{ grid-area: reward; }

    .hud-size{ display:none; }

    .hud-card{
      flex-direction:column;
      justify-content:center;
      align-items:center;
      text-align:center;
      gap: 6px;
    }
    .hud-score .hud-value{ font-size: 32px; }
    .hud-best  .hud-value{ font-size: 26px; }
    .hud-moves .hud-value{ font-size: 24px; }

    .hud-reward{
      flex-direction:column;
      gap: 6px;
      padding: 10px 10px;
    }
    .hud-reward-ico{ font-size: 28px; }
    .hud-reward-txt{ font-size: 18px; font-weight: 900; }

    /* Bottom level bar */
    .levelbar{
      display:flex;
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 6;
      padding: 18px 18px calc(18px + env(safe-area-inset-bottom));
      background: rgba(0,0,0,.55);
      border-top: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      align-items:center;
      justify-content:space-between;
      text-transform: uppercase;
      font-weight: 900;
      letter-spacing: 1px;
    }
    .levelbar span{ font-size: 22px; opacity: .92; }
    .levelbar strong{ font-size: 28px; }

    .app{ padding-bottom: 84px; }
  }

  .stats{
    display:flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items:center;
    justify-content:center;
  }
  .pill{
    padding: 10px 12px;
    border-radius: 999px;
    background: rgba(0,0,0,.22);
    border: 1px solid rgba(255,255,255,.12);
    box-shadow: 0 12px 22px rgba(0,0,0,.25);
    font-weight: 700;
    font-size: 13px;
    color: rgba(255,255,255,.82);
    letter-spacing: .2px;
    white-space: nowrap;
  }
  .pill strong{
    color: rgba(255,255,255,.95);
    font-weight: 800;
  }

  .btns{
    display:flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items:center;
    justify-content:flex-end;
  }

  button{
    font-family: inherit;
    font-weight: 800;
    letter-spacing: .25px;
    border-radius: 14px;
    border: 0px solid rgba(255,255,255,.14);
    padding: 10px 14px;
    cursor:pointer;
    color: rgba(255,255,255,.92);
    background: transparent;
    box-shadow: 0 14px 28px rgba(0,0,0,.35);
    transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease;
    user-select:none;

  }
  button:hover{ transform: translateY(-1px); filter: brightness(1.06); }
  button:active{ transform: translateY(0px) scale(.98); box-shadow: 0 9px 18px rgba(0,0,0,.28); }
  button:focus-visible{ outline:none; box-shadow: 0 14px 28px rgba(0,0,0,.35), var(--ring); }

  #btnUndo{
    background:
      radial-gradient(130% 120% at 30% 20%, rgba(255,255,255,.22), rgba(255,255,255,.06)),
      linear-gradient(180deg, rgba(255,220,124,.26), rgba(255,220,124,.08));
  }
  #btnHint{
    background:
      radial-gradient(130% 120% at 30% 20%, rgba(255,255,255,.22), rgba(255,255,255,.06)),
      linear-gradient(180deg, rgba(245,124,215,.22), rgba(245,124,215,.08));
  }
  #btnNew{
    background:
      radial-gradient(130% 120% at 30% 20%, rgba(255,255,255,.22), rgba(255,255,255,.06)),
      linear-gradient(180deg, rgba(124,245,197,.28), rgba(124,245,197,.10));
  }

  /* ===== Board ===== */
  .board-wrap{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap: 10px;
    padding: 2px 0;
  }

  .board{
    position:relative;
    margin:auto;
    width: min(620px, 92vw);
    aspect-ratio: 1/1;
    border-radius: calc(var(--radius-xl) + 2px);
    padding: var(--board-pad);
    border: 1px solid rgba(255,255,255,.16);
    background:
      radial-gradient(120% 120% at 20% 15%, rgba(255,255,255,.10), rgba(255,255,255,.02) 42%, rgba(0,0,0,.12) 70%),
      linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    box-shadow: var(--shadow), var(--board-shadow-in);
    backdrop-filter: blur(18px);
    -webkit-backdrop-filter: blur(18px);
    overflow:hidden;
    touch-action:none;
    user-select:none;
    direction: ltr;
  }

  /* Inner animated border + glow */
  .board::before{
    content:"";
    position:absolute;
    inset: 10px;
    border-radius: calc(var(--radius-xl) - 4px);
    background: conic-gradient(from 90deg, rgba(124,245,197,.0), rgba(124,245,197,.30), rgba(124,170,245,.22), rgba(245,124,215,.22), rgba(124,245,197,.30), rgba(124,245,197,.0));
    opacity:.35;
    filter: blur(10px);
    pointer-events:none;
    animation: boardGlow 6.5s ease-in-out infinite alternate;
  }
  @keyframes boardGlow{
    0%{ transform: rotate(-6deg) scale(1.02); opacity:.30; }
    100%{ transform: rotate(6deg) scale(1.06); opacity:.42; }
  }

  .grid{
    position:absolute;
    inset: var(--board-pad);
    display:grid;
    gap: var(--gap);
    z-index: 1;
    direction: ltr;
  }
  .cell{
    border-radius: var(--tile-round);
    background:
      radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.10), rgba(255,255,255,.02)),
      rgba(0,0,0,.18);
    border: 1px solid rgba(255,255,255,.10);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.10), inset 0 -10px 20px rgba(0,0,0,.35);
  }

  .tiles-layer{
    position:absolute;
    inset: var(--board-pad);
    z-index: 2;
  }

  /* ===== Tiles ===== */
  .tile{
    position:absolute;
    border-radius: var(--tile-round);
    border: 1px solid rgba(255,255,255,.35);
    background: var(--tileColor, rgba(255,255,255,.92));
    box-shadow: var(--tile-shadow);
    display:flex;
    align-items:center;
    justify-content:center;
    width: var(--w);
    height: var(--h);
    transform: translate(var(--x), var(--y)) scale(var(--s, 1));
    transition:
      transform var(--anim-move) cubic-bezier(.15,.85,.20,1),
      opacity var(--anim-fade) ease,
      filter 200ms ease,
      box-shadow 200ms ease;
    will-change: transform, opacity;
    overflow:hidden;
    backface-visibility: hidden;
  }
  /* Candy-glass highlights */
  .tile::before{
    content:"";
    position:absolute;
    inset: 0;
    background:
      radial-gradient(120% 80% at 30% 20%, rgba(255,255,255,.55), transparent 55%),
      linear-gradient(180deg, rgba(255,255,255,.18), transparent 55%);
    opacity:.55;
    pointer-events:none;
    mix-blend-mode: soft-light;
  }
  .tile::after{
    content:"";
    position:absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,.35),
      inset 0 -18px 40px rgba(0,0,0,.18);
    pointer-events:none;
    opacity:.85;
  }

  .glyph{
    position:relative;
    width: 78%;
    height: 78%;
    display:flex;
    align-items:center;
    justify-content:center;
    filter: drop-shadow(0 10px 24px rgba(0,0,0,.28));
  }
  .glyph svg{
    width: 100%;
    height: 100%;
    stroke: rgba(255,255,255,.96);
    fill: rgba(255,255,255,.96);
    stroke-width: 8;
    vector-effect: non-scaling-stroke;
    paint-order: stroke;
  }

  .tile.prebreak{
    animation: prebreak var(--anim-prebreak) ease-in-out;
    filter: saturate(1.12) brightness(1.06);
    box-shadow: 0 20px 65px rgba(245,124,215,.18), var(--tile-shadow);
  }
  @keyframes prebreak{
    0%{ transform: translate(var(--x), var(--y)) scale(1); }
    35%{ transform: translate(var(--x), var(--y)) scale(1.06) rotate(1deg); }
    65%{ transform: translate(var(--x), var(--y)) scale(1.02) rotate(-1deg); }
    100%{ transform: translate(var(--x), var(--y)) scale(1); }
  }
    /* prebreak "lite" (mobile/lowgfx): solo transform, niente filter/box-shadow */
  .tile.prebreakLite{
    animation: prebreakLite var(--anim-prebreak) ease-in-out;
  }
  @keyframes prebreakLite{
    0%{   transform: translate(var(--x), var(--y)) scale(1); }
    35%{  transform: translate(var(--x), var(--y)) scale(1.05) rotate(1deg); }
    65%{  transform: translate(var(--x), var(--y)) scale(1.01) rotate(-1deg); }
    100%{ transform: translate(var(--x), var(--y)) scale(1); }
  }

  .tile.fadeout{
    opacity:0;
    transform: translate(var(--x), var(--y)) scale(.88);
    filter: blur(1px);
  }
  /* ===== MASS BREAK PERFORMANCE (mobile) ===== */
  html.massbreak .tile.prebreak{
    animation: none !important;
    filter: none !important;
    box-shadow: var(--tile-shadow) !important; /* niente mega glow */
  }
  html.massbreak .tile.prebreakLite{
    animation: none !important;
  }


  html.massbreak .tile.fadeout{
    filter: none !important; /* il blur su 20 tile inchioda molti telefoni */
  }

  .small{
    font-size: 13px;
    font-weight: 600;
    color: rgba(255,255,255,.68);
    text-align:center;
    max-width: 58ch;
  }

  #btn-logout{
    margin-top: 6px;
    background:
      radial-gradient(130% 120% at 30% 20%, rgba(255,255,255,.20), rgba(255,255,255,.06)),
      linear-gradient(180deg, rgba(255,124,124,.22), rgba(255,124,124,.08));
  }

  /* ===== Overlays / Modals ===== */
  .hidden{ display:none !important; }

  .modal-overlay{
    position: fixed;
    inset: 0;
    z-index: 50;
    display:none;
    align-items:center;
    justify-content:center;
    padding: clamp(14px, 3vw, 24px);
    background:
      radial-gradient(1200px 900px at 50% 20%, rgba(124,245,197,.12), transparent 55%),
      rgba(0,0,0,.55);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }

  .modal-overlay.show{ display:flex !important; }

  .login-overlay{
    position: fixed;
    inset: 0;
    z-index: 50;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: clamp(14px, 3vw, 24px);
    background:
      radial-gradient(1200px 900px at 50% 20%, rgba(124,245,197,.12), transparent 55%),
      rgba(0,0,0,.55);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }

  .modal,
  .login-modal{
    width: min(520px, 100%);
    border-radius: var(--radius-xl);
    border: 1px solid rgba(255,255,255,.16);
    background:
      radial-gradient(120% 120% at 20% 15%, rgba(255,255,255,.14), rgba(255,255,255,.05)),
      rgba(0,0,0,.28);
    box-shadow: var(--shadow);
    overflow:hidden;
    transform: translateY(0);
  }

  .modal header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    padding: 14px 16px;
    border-bottom: 1px solid rgba(255,255,255,.10);
    background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
  }
  .modal header h2{
    margin:0;
    font-family: "Baloo 2", "Sora", ui-sans-serif;
    font-weight: 800;
    letter-spacing: .3px;
    flex: 1;
    min-width: 0;


  }
  .modal header button{
    padding: 8px 12px;
    border-radius: 12px;
    box-shadow: 0 10px 18px rgba(0,0,0,.25);
    background:
      radial-gradient(140% 130% at 20% 20%, rgba(255,255,255,.18), rgba(255,255,255,.06)),
      rgba(0,0,0,.18);
  }

  .content{ padding: 16px; }

  .account-card{
    border-radius: var(--radius-lg);
    background: rgba(0,0,0,.20);
    border: 1px solid rgba(255,255,255,.10);
    padding: 14px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
  }
  .row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 12px;
    padding: 10px 0;
    border-bottom: 1px solid rgba(255,255,255,.08);
  }
  .row:last-child{ border-bottom:none; }
  .k{
    color: rgba(255,255,255,.70);
    font-weight: 700;
  }
  .v{
    color: rgba(255,255,255,.92);
    font-weight: 800;
  }

  .account-actions{
    display:flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 14px;
  }

  .warn{
    background:
      radial-gradient(130% 120% at 30% 20%, rgba(255,255,255,.22), rgba(255,255,255,.06)),
      linear-gradient(180deg, rgba(255,220,124,.22), rgba(255,220,124,.08)) !important;
  }
  .danger{
    background:
      radial-gradient(130% 120% at 30% 20%, rgba(255,255,255,.22), rgba(255,255,255,.06)),
      linear-gradient(180deg, rgba(255,124,124,.26), rgba(255,124,124,.10)) !important;
  }

  /* Hint overlay mini-board */
  .hint-board{
    border-radius: var(--radius-lg);
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
    padding: 12px;
    min-height: 220px;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }
  .hint-text{
    margin: 12px 0 0 0;
    color: rgba(255,255,255,.78);
    font-weight: 650;
    line-height: 1.25;
  }

  /* ===== Toast ===== */
  .toast{
    position: fixed;
    left: 50%;
    bottom: calc(18px + env(safe-area-inset-bottom));
    transform: translateX(-50%) translateY(20px);
    opacity: 0;
    z-index: 60;
    padding: 12px 14px;
    border-radius: 999px;
    background: rgba(0,0,0,.40);
    border: 1px solid rgba(255,255,255,.14);
    backdrop-filter: blur(14px);
    -webkit-backdrop-filter: blur(14px);
    box-shadow: 0 14px 30px rgba(0,0,0,.35);
    color: rgba(255,255,255,.92);
    font-weight: 800;
    transition: opacity 220ms ease, transform 220ms ease;
    pointer-events:none;
    white-space: nowrap;
    max-width: min(92vw, 800px);
    overflow:hidden;
    text-overflow: ellipsis;
  }
  .toast.show{
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
  /* toast "BIG" (usato da bigToast) */
  .toast.big{
    top: 50%;
    bottom: auto;
    transform: translateX(-50%) translateY(-50%);
    padding: 18px 22px;
    border-radius: 22px;
    font-size: 22px;
    letter-spacing: .6px;
    background: rgba(0,0,0,.55);
    border: 1px solid rgba(255,255,255,.18);
  }

  /* STALLO overlay */
  .stallo-msg{
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    font-family: "Baloo 2", "Sora", system-ui;
    font-weight: 900;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: rgba(255,255,255,.96);
    text-shadow: 0 10px 30px rgba(0,0,0,.55);
  }
  .stallo-msg::before{
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at center, rgba(0,0,0,.35), rgba(0,0,0,.10), rgba(0,0,0,0));
  }
  .stallo-msg.hidden{ display:none; }
  .stallo-msg > span{ position: relative; }



  /* ===== Inputs ===== */
  input[type="text"]{
    width: 100%;
    border-radius: 16px;
    padding: 12px 14px;
    margin-top: 10px;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.22);
    color: rgba(255,255,255,.92);
    font-weight: 700;
    outline: none;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
    transition: box-shadow 160ms ease, border-color 160ms ease;
  }
  input[type="text"]::placeholder{
    color: rgba(255,255,255,.55);
    font-weight: 650;
  }
  input[type="text"]:focus{
    border-color: rgba(124,245,197,.35);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.10), var(--ring);
  }

  .login-modal{
    padding: 18px;
  }
  .login-modal h2{
    margin: 0 0 6px 0;
    font-family: "Baloo 2", "Sora";
    font-weight: 800;
    letter-spacing: .3px;
  }
  .login-modal button{
    width: 100%;
    margin-top: 10px;
  }

  /* ===== Layout responsiveness ===== */
  @media (max-width: 760px){
    .topbar{
      flex-direction: column;
      align-items: stretch;
      gap: 12px;
    }
    .btns{ justify-content: center; }
    .stats{ justify-content: center; }
    .title{ align-items: center; text-align: center; }
    .userbadge{ margin: 0 auto; }
  }

  @media (max-width: 420px){
      /* app più stretta e centrata */
      .app{
        width: min(420px, 100%);
        margin: 0 auto;
      }

      .topbar{
        padding: 12px 12px;
        gap: 10px;
      }

      /* ⚙️ in alto a destra */
      .userbox{
        position: absolute;
        top: 12px;
        right: 12px;
        z-index: 3;
      }

      /* lascia spazio a destra per non sovrapporre il titolo con ⚙️ */
      .title{
        align-items: center;
        text-align: center;
        padding-right: 54px; /* ≈ larghezza icona */
        padding-left: 54px;  /* simmetria estetica */
      }

      /* pills più compatti */
      .stats{
        gap: 8px;
      }
      .pill{
        padding: 8px 10px;
        font-size: 12px;
      }

      /* pulsanti: riga compatta (icona + 2 bottoni), poi AD a tutta larghezza */
      .btns{
        width: 100%;
        display: grid;
        grid-template-columns: 44px 1fr 1fr;
        gap: 10px;
        justify-content: stretch;
        align-items: center;
      }

      #btnUndo{
        width: 50px;
        height: 50px;
      }

      #btnAuto, #btnNew{
        width: 100%;
      }

      #btnReward2Hints{
        grid-column: 1 / -1;
        width: 100%;
      }

      #rewardOverlayStatus{
        grid-column: 1 / -1;
        margin-top: -2px;
        text-align: center;
      }

      /* Hint (lampadina) compatto in basso a sinistra */
      .hint-btn-wrap{
        align-self: flex-start;
      }
      #btnHint{
        width: 44px;
        height: 44px;
      }
    }

  @media (prefers-reduced-motion: reduce){
    body::before, body::after,
    .topbar::before, .board::before{ animation: none !important; }
    *{ scroll-behavior: auto !important; transition: none !important; }
  }

  /* ===== Particles (FAST) ===== */
  .stars{
    position:absolute;
    width:1px;
    height:1px;
    pointer-events:none;
    contain: layout paint;
    transform: translate3d(0,0,0);
  }

  .star{
    position:absolute;
    left:0;
    top:0;

    /* spark leggero (niente SVG) */
    width: 7px;
    height: 7px;
    border-radius: 999px;
    background: rgba(255,255,255,.95);

    /* glow leggero (mobile-friendly) */
    box-shadow: 0 0 10px rgba(124,245,197,.25);

    will-change: transform, opacity;
    transform: translate3d(0,0,0) scale(1);
    animation: star-pop max(calc(0.42s / var(--anim-fx)), 0.06s) cubic-bezier(.16,.84,.26,1) forwards;
  }

  /* modalità lowgfx: glow quasi nullo */
  html.lowgfx .star{
    box-shadow: 0 0 6px rgba(124,245,197,.18);
  }

  @keyframes star-pop{
    from{ opacity:1; transform: translate3d(0,0,0) scale(1) rotate(0deg); }
    to  { opacity:0; transform: translate3d(var(--dx), var(--dy), 0) scale(var(--sc)) rotate(var(--rot)); }
  }




  /* ===== Settings toggle ===== */
  .settings-note{
    font-size: 12px;
    line-height: 1.25;
    color: rgba(255,255,255,.62);
    max-width: 40ch;
  }
  .switch{
    position: relative;
    display: inline-block;
    width: 54px;
    height: 32px;
    flex: 0 0 auto;
  }
  .switch input{ opacity:0; width:0; height:0; }
  .slider{
    position:absolute;
    inset:0;
    cursor:pointer;
    border-radius: 999px;
    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.10), 0 12px 24px rgba(0,0,0,.28);
    transition: all 180ms ease;
  }
  .slider::before{
    content:"";
    position:absolute;
    width: 26px;
    height: 26px;
    left: 3px;
    top: 2px;
    border-radius: 50%;
    background: linear-gradient(180deg, rgba(255,255,255,.88), rgba(255,255,255,.56));
    box-shadow: 0 10px 18px rgba(0,0,0,.28);
    transition: transform 180ms ease;
  }
  .switch input:checked + .slider{
    background: rgba(124,245,197,.22);
    border-color: rgba(124,245,197,.35);
  }
  .switch input:checked + .slider::before{ transform: translateX(22px); }

  /* ===== Instant mode: remove waits/visual transitions (FX stars unchanged) ===== */
  html.instant .tile{ transition: none !important; }
  html.instant .tile.prebreak{ animation: none !important; }
  html.instant .tile.fadeout{ transition: none !important; }

  .ad-banner-slot{
    width:100%;
    min-height:50px; /* banner standard */
    display:flex;
    align-items:center;
    justify-content:center;
    margin-top:10px;
  }

  .hint-btn-wrap{
    position: relative;
    display: inline-block;
  }

  .hint-badge{
    position: absolute;
    top: -8px;
    right: -8px;
    min-width: 18px;
    height: 18px;
    padding: 0 5px;

    display: inline-flex;
    align-items: center;
    justify-content: center;

    border-radius: 999px;
    background: #e53935;
    color: #fff;
    font-size: 12px;
    font-weight: 800;
    line-height: 1;

    border: 2px solid rgba(255,255,255,.85);
    box-shadow: 0 6px 16px rgba(0,0,0,.18);
    user-select: none;
    pointer-events: none;
  }

  
  /* Offline overlay */
  .offline-overlay{
    position: fixed;
    inset: 0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,.55);
    z-index: 10000;
  }
  .offline-overlay.hidden{ display:none; }
  .offline-card{
    width: min(420px, 92vw);
    background: rgba(24,24,28,.92);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 18px;
    padding: 18px 16px;
    box-shadow: 0 24px 60px rgba(0,0,0,.45);
    color: rgba(255,255,255,.92);
    text-align:center;
  }
  .offline-title{ font-weight: 800; font-size: 18px; margin-bottom: 8px; }
  .offline-text{ opacity: .9; line-height: 1.35; }
  .offline-actions{ display:flex; gap:10px; justify-content:center; margin-top: 14px; }

.reward-overlay{
    position: fixed;
    inset: 0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,.45);
    z-index: 9999;
  }

  .reward-overlay.hidden{ display:none; }

  .reward-card{
    width: min(420px, 92vw);
    background: rgba(255,255,255,.92);
    color: #111;
    border-radius: 16px;
    padding: 16px;
    box-shadow: 0 18px 60px rgba(0,0,0,.25);
  }

  .reward-title{ font-weight: 800; font-size: 16px; margin-bottom: 6px; }
  .reward-text{ font-size: 14px; line-height: 1.3; }

  .reward-actions{
    display:flex;
    gap: 10px;
    margin-top: 12px;
  }

/* =========================
   GAME OVER OVERLAY
   ========================= */

  .gameover{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.55);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 99999; /* sopra tutto */
    flex-direction: column;
    gap: 170px;
  }


  .gameover-bar{
    width: min(500px, 300vw);
    background: transparent;
    padding: 18px;
    text-align: center;
  }

  .gameover.hidden{ display: none; }

  .gameover-card{
    width: min(500px, 300vw);
    background: transparent;
    padding: 18px;
    text-align: center;

        /* Standard (supporto parziale) */
    animation: spinBorder 32s linear infinite;

  }


.gameover-title {
  font-size: 50px;
  font-weight: 800;
  margin-bottom: 6px;

  filter:
    blur(0.2px)
    brightness(3.2)
    drop-shadow(0 0 10px rgba(124,245,197,.8))
    drop-shadow(0 0 18px rgba(124,170,245,.7))
    drop-shadow(0 0 26px rgba(245,124,215,.6));
}


  .gameover-text{
    font-size: 30px;
    opacity: .85;
  }

  .gameover-actions{
    display: flex;
    gap: 10px;
    margin-top: 14px;
    justify-content: center;
  }

  /* stile bottoni (se non hai già classi btn) */
  #btnGameOverUndo, #btnGameOverClose{
    padding: 30px 53px;
    border-radius: 12px;
    border: 0;
    font-weight: 800;
    cursor: pointer;
      text-shadow:
    0 0 10px rgba(124,245,197,.9),
    0 0 20px rgba(124,170,245,.8),
    0 0 30px rgba(245,124,215,.7);
  }

  /* Undo disabilitato: colore diverso */
  #btnGameOverUndo.undo-disabled,
  #btnGameOverUndo:disabled{
    background: #9aa0a6;
    color: #fff;
    opacity: .65;
    cursor: not-allowed;
  }

  /* Chiudi/Ricomincia (se vuoi differenziarlo) */
  #btnGameOverClose{
    background: #111;
    color: #fff;
  }



  #btnGameOverUndo{
    background: #4e9e80;
    color: #fff;
  }

  .stallo-msg {
    position: fixed;
    inset: 0;                 /* copre tutto lo schermo */
    z-index: 10000;           /* sopra TUTTO */

    display: flex;
    align-items: center;
    justify-content: center;

    font-size: 48px;
    font-weight: 900;
    letter-spacing: 3px;
    text-transform: uppercase;

    color: #ffffff;
    background: rgba(0, 0, 0, 0.55); /* velo scuro davanti al gioco */

    pointer-events: none;     /* NON blocca il gioco */
    animation: stalloFade 1.2s ease forwards;
  }

  .stallo-msg.hidden {
    display: none;
  }

  @keyframes stalloFade {
    0%   { opacity: 0; transform: scale(0.9); }
    20%  { opacity: 1; transform: scale(1.05); }
    80%  { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(0.95); }
  }

  @keyframes undoPulse {
    0%   { transform: scale(1); }
    50%  { transform: scale(1.18); }
    100% { transform: scale(1); }
  }

  .undo-pulse {
    animation: undoPulse 0.8s ease-in-out infinite;
    will-change: transform;
  }



  .spinner{
    width: 34px;
    height: 34px;
    margin: 14px auto 0 auto;
    border-radius: 50%;
    border: 4px solid rgba(255,255,255,.18);
    border-top-color: rgba(255,255,255,.92);
    animation: spin 0.9s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .hidden{ display:none !important; }

  .reward-overlay{
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,.6);
    z-index: 9999;
  }
  .reward-card{
    background: #111827;
    color: #fff;
    padding: 18px;
    width: min(420px, 92vw);
    border-radius: 14px;
    box-shadow: 0 10px 40px rgba(0,0,0,.35);
  }
  .hidden{ display:none !important; }


  /* =========================================================
     HUD layout fix (mobile-first, 3-col with right stack)
     - Keeps logic intact (same IDs), only layout.
     ========================================================= */

  /* Desktop / wide */
  .hud{
    display:grid;
    gap:10px;
    align-items:stretch;
    grid-template-columns: repeat(4, minmax(88px, 1fr)) auto;
    grid-template-areas:
      "score best moves size right"
      "status status status status status";
  }
  .hud-score{ grid-area: score; }
  .hud-best{  grid-area: best; }
  .hud-moves{ grid-area: moves; }
  .hud-size{  grid-area: size; }
  .hud-right{
    grid-area: right;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:stretch;
    justify-content:space-between;
  }
  .reward-status{
    grid-area: status;
    grid-column: auto;
  }
  .hud-size{ grid-column:auto; }

  .hud-btn{
    width:100px;
    height:auto;
    border-radius:18px;
    display:grid;
    place-items:center;
  }
  .hud-icon{
    width:100%;
    height:100%;
    object-fit:contain;
    display:block;
    pointer-events:none;
  }

  .iconbtn img{
    width:100%;
    height:100%;
    object-fit:contain;
    display:block;
    pointer-events:none;
  }

  /* Mobile */
  @media (max-width: 520px){
    .hud{
      grid-template-columns: 1fr 1fr auto;
      grid-template-areas:
        "score moves right"
        "best  size  right"
        "status status status";
    }

    .hud-right{
      width:58px;
    }

    .hud-card{
      flex-direction:column;
      justify-content:center;
      align-items:center;
      text-align:center;
      gap:6px;
      min-height:56px;
      padding:10px 10px;
    }

    .hud-score .hud-value{ font-size: 30px; line-height: 1; }
    .hud-best  .hud-value{ font-size: 22px; line-height: 1; }
    .hud-moves .hud-value{ font-size: 22px; line-height: 1; }
    .hud-size  .hud-value{ font-size: 20px; line-height: 1; }

    .hud-size{ display:flex; }
    .hud-btn{
      width:58px;
      height:58px;
      border-radius:18px;
    }
    .hud-icon{ width:64%; height:64%; }
  }

  /* ===== RTL fixes (Arabic) ===== */
  html[dir="rtl"] .modal header{
    flex-direction: row-reverse;
  }

  html[dir="rtl"] .modal header h2{
    text-align: right;
  }

  /* Il contenuto dinamico dell’hint (spesso in EN) deve restare leggibile e non “uscire” */
  html[dir="rtl"] #hintOverlay #hintText{
    direction: ltr;
    unicode-bidi: plaintext;
    text-align: left;
  }

  /* La mini-board è un layout “tecnico”: meglio LTR per centrare e non invertire */
  html[dir="rtl"] #hintOverlay #hintCanvasWrap{
    direction: ltr;
  }

  /* La nota invece deve seguire la lingua (quindi RTL in arabo) */
  html[dir="rtl"] #hintOverlay .hint-note{
    direction: rtl;
    text-align: center;
  }

  /* ===== Icon-only transparent buttons ===== */
  .iconbtn.icononly{
    background: transparent !important;
    border: 0 !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;

    width: 52px;
    height: 52px;
    padding: 0;
    border-radius: 14px; /* solo per area clic, ma resta trasparente */
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .iconbtn.icononly:hover{
    transform: translateY(-1px);
    filter: brightness(1.12);
  }

  .iconbtn.icononly:active{
    transform: scale(.92);
    filter: brightness(1.05);
  }

  /* uniforma dimensione SVG */
  .iconbtn.icononly img{
    width: 85%;
    height: 85%;
    object-fit: contain;
  }
  #btnAuto.active{
    filter: drop-shadow(0 0 6px rgba(255,215,0,.55));
  }

  #btnHint, .iconbtn-hint{
    background: transparent !important;
    box-shadow: none !important;
  }
  #btnAccount{
    background: transparent !important;
    box-shadow: none !important;
    animation: spin 30s linear infinite;
  }

  #privacyOverlay{
    z-index: 99999;
  }


  #privacyOverlay .modal { overflow: hidden; }
  #privacyOverlay .content { flex: 1; min-height: 0; padding: 0 !important; }
  #privacyFrame { width: 100%; height: 100%; display: block; border: 0; }

  /* ===== Disable mobile tap highlight ===== */
  *{
    -webkit-tap-highlight-color: transparent;
  }

  .level-loading{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background: rgba(11, 12, 22, 0.112);
    z-index: 99999;
  }
  .level-loading.hidden{ display:none; }

  .level-loading-card{
    padding:18px 20px;
    border-radius:16px;
    background: transparent;
    border: 0px;
    text-align:center;
    backdrop-filter: blur(6px);
  }

  .spinner{
    width:32px; height:32px;
    border:3px solid rgba(255, 255, 255, 0.122);
    border-top-color: rgba(255, 255, 255, 0.32);
    border-radius:50%;
    animation: spin 0.8s linear infinite;
    margin:0 auto 10px;
  }

  @keyframes spin{ to{ transform: rotate(360deg); } }

</style>
</head>

<script>
    
  // === i18n (IT/EN/FR/DE/ES/RU/JLA/AR/ZH) ===
  const I18N = {
    it: {
      "label.level":"Livello",
      "label.grid":"Griglia",
      "label.moves":"Mosse",
      "label.score":"Score",
      "btn.undo":"Undo",
      "btn.auto":"TUTORIAL/AUTO",
      "btn.new":"Nuova",
      "btn.hint":"Hint",
      "btn.ad_hints":"AD +2 hint",
      "modal.account":"Account",
      "btn.close":"Chiudi",
      "label.nickname":"Nickname",
      "label.username":"Username",
      "label.anim_speed":"Velocità animazioni",
      "note.anim_speed":"Influisce su scorrimento e rottura. Le stelline restano uguali.",
      "btn.music_on":"Music: ON",
      "btn.music_off":"Music: OFF",
      "label.instant":"Movimento istantaneo",
      "note.instant":"Nessuna attesa: puoi scorrere anche mentre gli effetti sono in corso (l'animazione può essere tagliata).",
      "label.relax":"Relax mode",
      "note.relax":"Solo griglie 3×3 / 5×5. Niente 7×7 o 10×10 (non cambia il punteggio, solo la difficoltà).",
      "label.user_id":"User ID 1.0",
      "label.language":"Lingua",
      "btn.logout":"Logout",
      "btn.reset_progress":"Reset progressi",
      "btn.delete_account":"Elimina account",
      "note.reset_delete":"<span data-i18n=\"note.reset_delete\">Nota: “Reset progressi” azzera solo i progressi locali su questo device. “Elimina account” richiede endpoint backend (lo facciamo dopo).</span>",
      "toast.new_game":"Nuova partita",
      "confirm.new_game":"Vuoi iniziare una nuova partita? Il salvataggio attuale verrà sovrascritto.",
      "confirm.reset_progress":"Vuoi azzerare i progressi locali su questo dispositivo?",
      "confirm.delete_account":"Sei sicuro? Tutti i dati associati al tuo account saranno eliminati. Azione irreversibile.",
      "stallo":"STALLO! PREMERE UNDO",
      "toast.reset_done":"Progressi resettati",
      "welcome.bonus_hints":"Ecco i tuoi hint di benvenuto:",
      "btn.haptics_on":"Vibrazione: ON",
      "btn.haptics_off":"Vibrazione: OFF",
      "account.need_login_delete": "Devi effettuare il login per eliminare l’account.",
      "account.reset_your_progress": "Vuoi davvero resettare i progressi? Questa azione non può essere annullata.",
      "mosse.finite":"Mosse finite!",
      "ui.ok":"OK",
      "ui.confirm":"Conferma",
      "ui.cancel":"Annulla",
      "login.nickname_too_short":"Inserisci un nickname di almeno 3 caratteri.",
      "passkey.register_failed":"Registrazione passkey fallita",
      "passkey.login_failed":"Login passkey fallito",
      "error.new_game":"Errore durante Nuova partita",
      "hint.title":"Hint — mossa suggerita",
      "hint.recharge":"L’hint si ricarica ogni 3 livelli.",
      "login.title":"Accedi al gioco",
      "login.nickname_ph":"Nickname (min 3 caratteri)",
      "login.passkey_login":"Accedi con impronta / Face ID",
      "login.passkey_register":"Crea passkey (senza password)",
      "login.guest":"Gioca senza account",
      "login.note":"Nota: su alcuni dispositivi il nickname può essere opzionale per il login (discoverable passkeys).",
      "label.best_score":"Punteggio più alto",
      "Ads1":"Hai esaurito gli hint?",
      "Ads2":"Guarda un annuncio per ottenere 2 hint extra :)",
      "Congratulations!":"Complimenti! Hai completato il livello",
      "prepare":"Calcolo il prossimo livello...",
    },
    en: {
      "label.level":"Level",
      "label.grid":"Grid",
      "label.moves":"Moves",
      "label.score":"Score",
      "btn.undo":"Undo",
      "btn.auto":"TUTORIAL/AUTO",
      "btn.new":"New",
      "btn.hint":"Hint",
      "btn.ad_hints":"AD +2 hints",
      "modal.account":"Account",
      "btn.close":"Close",
      "label.nickname":"Nickname",
      "label.username":"Username",
      "label.anim_speed":"Animation speed",
      "note.anim_speed":"Affects scrolling and breaking. Stars stay the same.",
      "btn.music_on":"Music: ON",
      "btn.music_off":"Music: OFF",
      "label.instant":"Instant move",
      "note.instant":"No waiting: you can swipe even while effects run (animation may be cut).",
      "label.relax":"Relax mode",
      "note.relax":"Only 3×3 / 5×5 grids. No 7×7 or 10×10 (score unchanged, only difficulty).",
      "label.user_id":"User ID",
      "label.language":"Language",
      "btn.logout":"Logout",
      "btn.reset_progress":"Reset progress",
      "btn.delete_account":"Delete account",
      "note.reset_delete":"Note: “Reset progress” clears only local progress on this device. “Delete account” requires a backend endpoint (we'll add it later).",
      "toast.new_game":"New game",
      "confirm.new_game":"Start a new game? Your current save will be overwritten.",
      "confirm.reset_progress":"Reset local progress on this device?",
      "confirm.delete_account":"Are you sure? All data linked to your account will be deleted. This cannot be undone.",
      "stallo":"STALLED! PRESS UNDO",
      "toast.reset_done":"Progress reset",
      "welcome.bonus_hints":"Here are your welcome hints:",
      "btn.haptics_on":"Haptics: ON",
      "btn.haptics_off":"Haptics: OFF",
      "account.need_login_delete": "You need to be logged in to delete the account.",
      "account.reset_your_progress": "Do you really want to reset your progress? This action cannot be undone.",
      "mosse.finite":"No more moves!",
      "ui.ok":"OK",
      "ui.confirm":"Confirm",
      "ui.cancel":"Cancel",
      "login.nickname_too_short": "Please enter a nickname of at least 3 characters.",
      "passkey.register_failed": "Passkey registration failed",
      "passkey.login_failed": "Passkey login failed",
      "error.new_game": "Error during New Game",
      "hint.title":"Hint — suggested move",
      "hint.recharge":"Hints recharge every 3 levels.",
      "login.title":"Sign in",
      "login.nickname_ph":"Nickname (min 3 chars)",
      "login.passkey_login":"Sign in with Touch ID / Face ID",
      "login.passkey_register":"Create passkey (no password)",
      "login.guest":"Play as guest",
      "login.note":"Note: on some devices nickname can be optional (discoverable passkeys).",
      "label.best_score":"Highest score",
      "Ads1":"Out of hints?",
      "Ads2":"Watch an ad to get 2 extra hints :)",
      "Congratulations!": "Congratulations! You completed the level",
      "prepare":"Calculating next level...",
    },
    fr: {
      "label.level":"Niveau",
      "label.grid":"Grille",
      "label.moves":"Coups",
      "label.score":"Score",
      "btn.undo":"Annuler",
      "btn.auto":"TUTORIEL/AUTO",
      "btn.new":"Nouveau",
      "btn.hint":"Indice",
      "btn.ad_hints":"PUB +2 indices",
      "modal.account":"Compte",
      "btn.close":"Fermer",
      "label.nickname":"Pseudo",
      "label.username":"Nom d’utilisateur",
      "label.anim_speed":"Vitesse d’animation",
      "note.anim_speed":"Influe sur le défilement et la casse. Les étoiles restent identiques.",
      "btn.music_on":"Musique : ON",
      "btn.music_off":"Musique : OFF",
      "label.instant":"Mouvement instantané",
      "note.instant":"Aucune attente : glisse même pendant les effets (animation parfois coupée).",
      "label.relax":"Mode relax",
      "note.relax":"Seulement 3×3 / 5×5. Pas de 7×7 ou 10×10 (score inchangé, difficulté seulement).",
      "label.user_id":"ID utilisateur",
      "label.language":"Langue",
      "btn.logout":"Déconnexion",
      "btn.reset_progress":"Réinitialiser",
      "btn.delete_account":"Supprimer le compte",
      "note.reset_delete":"Note : “Réinitialiser” efface seulement les progrès locaux. “Supprimer le compte” nécessite un endpoint backend (plus tard).",
      "toast.new_game":"Nouvelle partie",
      "confirm.new_game":"Démarrer une nouvelle partie ? La sauvegarde actuelle sera écrasée.",
      "confirm.reset_progress":"Réinitialiser les progrès locaux sur cet appareil ?",
      "confirm.delete_account":"Êtes-vous sûr ? Toutes les données seront supprimées. Action irréversible.",
      "stallo":"BLOQUÉ ! APPUYEZ SUR ANNULER",
      "toast.reset_done":"Progrès réinitialisés",
      "welcome.bonus_hints":"Voici tes indices de bienvenue :",
      "btn.haptics_on":"Vibrations : ON",
      "btn.haptics_off":"Vibrations : OFF",
      "account.need_login_delete": "Vous devez être connecté pour supprimer le compte.",
      "account.reset_your_progress":  "Voulez-vous vraiment réinitialiser vos progrès ? Cette action est irréversible.",
      "mosse.finite":"Plus de coups possibles !",
      "ui.ok":"OK",
      "ui.confirm":"Confirmer",
      "ui.cancel":"Annuler",
      "login.nickname_too_short": "Veuillez entrer un pseudo d’au moins 3 caractères.",
      "passkey.register_failed": "Échec de l’enregistrement de la passkey",
      "passkey.login_failed": "Échec de la connexion avec la passkey",
      "error.new_game": "Erreur lors de la nouvelle partie",
      "hint.title":"Indice — mouvement suggéré",
      "hint.recharge":"Les indices se recharge tous les 3 niveaux.",
      "login.title":"Se connecter",
      "login.nickname_ph":"Pseudo (min 3 caractères)",
      "login.passkey_login":"Se connecter avec Touch ID / Face ID",
      "login.passkey_register":"Créer une passkey (sans mot de passe)",
      "login.guest":"Jouer en tant qu’invité",
      "login.note":"Note : sur certains appareils, le pseudo peut être optionnel pour la connexion (passkeys découvrables).",
      "Ads1":"Plus d’indices ?",
      "Ads2":"Regardez une publicité pour obtenir 2 indices supplémentaires :)",
      "Congratulations!":"Félicitations ! Vous avez terminé le niveau.",
      "prepare":"Calcul en cours du prochain niveau...",
    },
    de: {
      "label.level":"Level",
      "label.grid":"Gitter",
      "label.moves":"Züge",
      "label.score":"Punkte",
      "btn.undo":"Rückgängig",
      "btn.auto":"TUTORIAL/AUTO",
      "btn.new":"Neu",
      "btn.hint":"Hinweis",
      "btn.ad_hints":"WERBUNG +2 Hinweise",
      "modal.account":"Konto",
      "btn.close":"Schließen",
      "label.nickname":"Nickname",
      "label.username":"Benutzername",
      "label.anim_speed":"Animationsgeschwindigkeit",
      "note.anim_speed":"Beeinflusst Scrollen und Zerbrechen. Sterne bleiben gleich.",
      "btn.music_on":"Musik: AN",
      "btn.music_off":"Musik: AUS",
      "label.instant":"Sofortzug",
      "note.instant":"Keine Wartezeit: Wischen auch während Effekten (Animation kann abgeschnitten werden).",
      "label.relax":"Relax-Modus",
      "note.relax":"Nur 3×3 / 5×5. Kein 7×7 oder 10×10 (Punkte gleich, nur Schwierigkeit).",
      "label.user_id":"User-ID",
      "label.language":"Sprache",
      "btn.logout":"Abmelden",
      "btn.reset_progress":"Fortschritt zurücksetzen",
      "btn.delete_account":"Konto löschen",
      "note.reset_delete":"Hinweis: „Fortschritt zurücksetzen“ löscht nur lokale Daten auf diesem Gerät. „Konto löschen“ braucht ein Backend (später).",
      "toast.new_game":"Neues Spiel",
      "confirm.new_game":"Neues Spiel starten? Dein aktueller Spielstand wird überschrieben.",
      "confirm.reset_progress":"Lokalen Fortschritt auf diesem Gerät zurücksetzen?",
      "confirm.delete_account":"Bist du sicher? Alle Kontodaten werden gelöscht. Nicht rückgängig machbar.",
      "stallo":"BLOCKIERT! DRÜCKE RÜCKGÄNGIG",
      "toast.reset_done":"Fortschritt zurückgesetzt",
      "welcome.bonus_hints":"Hier sind deine Willkommens-Hinweise:",
      "btn.haptics_on":"Vibration: AN",
      "btn.haptics_off":"Vibration: AUS",
      "account.need_login_delete": "Du musst eingeloggt sein, um das Konto zu löschen.",
      "account.reset_your_progress": "Willst du deinen Fortschritt wirklich zurücksetzen? Diese Aktion kann nicht rückgängig gemacht werden.",
      "mosse.finite":"Keine Züge mehr möglich",
      "ui.ok":"OK",
      "ui.confirm":"Bestätigen",
      "ui.cancel": "Abbrechen",
      "login.nickname_too_short": "Bitte gib einen Nickname mit mindestens 3 Zeichen ein.",
      "passkey.register_failed": "Passkey-Registrierung fehlgeschlagen",
      "passkey.login_failed": "Passkey-Login fehlgeschlagen",
      "error.new_game": "Fehler beim Starten eines neuen Spiels",
      "hint.title":"Hinweis — vorgeschlagener Zug",
      "hint.recharge":"Hinweise werden alle 3 Level neu geladen.",
      "login.title":"Anmelden",
      "login.nickname_ph":"Nickname (min 3 Zeichen)",
      "login.passkey_login":"Mit Touch ID / Face ID anmelden",
      "login.passkey_register":"Passkey erstellen (ohne Passwort)",
      "login.guest":"Als Gast spielen",
      "login.note":"Hinweis: Auf einigen Geräten kann der Nickname für die Anmeldung optional sein (discoverable passkeys).",
      "label.best_score":"Höchste Punktzahl",
      "Ads1":"Keine Hinweise mehr?",
      "Ads2":"Schau dir eine Werbung an, um 2 zusätzliche Hinweise zu erhalten :)",
      "Congratulations!": "Herzlichen Glückwunsch, du hast das Level abgeschlossen.",
      "prepare": "Ich berechne das nächste Level.",
    },
    es: {
      "label.level":"Nivel",
      "label.grid":"Cuadrícula",
      "label.moves":"Movimientos",
      "label.score":"Puntuación",
      "btn.undo":"Deshacer",
      "btn.auto":"TUTORIAL/AUTO",
      "btn.new":"Nuevo",
      "btn.hint":"Pista",
      "btn.ad_hints":"ANUNCIO +2 pistas",
      "modal.account":"Cuenta",
      "btn.close":"Cerrar",
      "label.nickname":"Apodo",
      "label.username":"Usuario",
      "label.anim_speed":"Velocidad de animación",
      "note.anim_speed":"Afecta al deslizamiento y rotura. Las estrellas se mantienen.",
      "btn.music_on":"Música: ON",
      "btn.music_off":"Música: OFF",
      "label.instant":"Movimiento instantáneo",
      "note.instant":"Sin espera: puedes deslizar mientras corren efectos (la animación puede cortarse).",
      "label.relax":"Modo relax",
      "note.relax":"Solo 3×3 / 5×5. Sin 7×7 o 10×10 (puntuación igual, solo dificultad).",
      "label.user_id":"ID de usuario",
      "label.language":"Idioma",
      "btn.logout":"Cerrar sesión",
      "btn.reset_progress":"Reiniciar progreso",
      "btn.delete_account":"Eliminar cuenta",
      "note.reset_delete":"Nota: “Reiniciar progreso” borra solo el progreso local en este dispositivo. “Eliminar cuenta” requiere backend (luego).",
      "toast.new_game":"Nueva partida",
      "confirm.new_game":"¿Empezar una nueva partida? Se sobrescribirá tu guardado actual.",
      "confirm.reset_progress":"¿Reiniciar el progreso local en este dispositivo?",
      "confirm.delete_account":"¿Seguro? Se eliminarán todos los datos de tu cuenta. Acción irreversible.",
      "stallo":"¡BLOQUEADO! PULSA DESHACER",
      "toast.reset_done":"Progreso reiniciado",
      "welcome.bonus_hints":"Aquí están tus pistas de bienvenida:",
      "btn.haptics_on":"Vibración: ON",
      "btn.haptics_off":"Vibración: OFF",
      "account.need_login_delete": "Necesitas iniciar sesión para eliminar la cuenta.",
      "account.reset_your_progress": "¿Realmente quieres reiniciar tu progreso? Esta acción no se puede deshacer.",
      "mosse.finite":"¡No quedan movimientos!",
      "ui.ok":"OK",
      "ui.confirm":"Confirmar",
      "ui.cancel":"Cancelar",
      "login.nickname_too_short": "Por favor, ingresa un apodo de al menos 3 caracteres.",
      "passkey.register_failed":  "Registro de passkey fallido",
      "passkey.login_failed": "Error de inicio de sesión con passkey",
      "error.new_game": "Error durante Nueva partida",
      "hint.title":"Pista — movimiento sugerido",
      "hint.recharge":"Las pistas se recargan cada 3 niveles.",
      "login.title":"Iniciar sesión",
      "login.nickname_ph":"Apodo (mín 3 caracteres)",
      "login.passkey_login":"Iniciar sesión con Touch ID / Face ID",
      "login.passkey_register":"Crear passkey (sin contraseña)",
      "login.guest":"Jugar sin cuenta",
      "login.note":"Nota: en algunos dispositivos el apodo puede ser opcional para iniciar sesión (discoverable passkeys).",
      "label.best_score":"Puntuación más alta",
      "Ads1":"¿Sin pistas?",
      "Ads2":"Mira un anuncio para obtener 2 pistas extra :)",
      "Congratulations!": "¡Felicidades! Completaste el nivel",
      "prepare": "Calculando el siguiente nivel...",
    },
    ru: {
      "label.level":"Уровень",
      "label.grid":"Сетка",
      "label.moves":"Ходы",
      "label.score":"Счёт",
      "btn.undo":"Отмена",
      "btn.auto":"ОБУЧЕНИЕ/АВТО",
      "btn.new":"Новая",
      "btn.hint":"Подсказка",
      "btn.ad_hints":"РЕКЛАМА +2 подсказки",
      "modal.account":"Аккаунт",
      "btn.close":"Закрыть",
      "label.nickname":"Ник",
      "label.username":"Имя пользователя",
      "label.anim_speed":"Скорость анимации",
      "note.anim_speed":"Влияет на прокрутку и разрушение. Звёзды не меняются.",
      "btn.music_on":"Музыка: ВКЛ",
      "btn.music_off":"Музыка: ВЫКЛ",
      "label.instant":"Мгновенный ход",
      "note.instant":"Без ожидания: свайпайте даже во время эффектов (анимация может обрезаться).",
      "label.relax":"Relax режим",
      "note.relax":"Только 3×3 / 5×5. Без 7×7 или 10×10 (счёт не меняется, только сложность).",
      "label.user_id":"ID пользователя",
      "label.language":"Язык",
      "btn.logout":"Выйти",
      "btn.reset_progress":"Сброс прогресса",
      "btn.delete_account":"Удалить аккаунт",
      "note.reset_delete":"Примечание: “Сброс прогресса” очищает только локальные данные. “Удалить аккаунт” требует backend (позже).",
      "toast.new_game":"Новая игра",
      "confirm.new_game":"Начать новую игру? Текущий прогресс будет перезаписан.",
      "confirm.reset_progress":"Сбросить локальный прогресс на этом устройстве?",
      "confirm.delete_account":"Вы уверены? Все данные аккаунта будут удалены. Это необратимо.",
      "stallo":"ЗАСТРЯЛО! НАЖМИТЕ ОТМЕНУ",
      "toast.reset_done":"Прогресс сброшен",
      "welcome.bonus_hints":"Вот ваши приветственные подсказки:",
      "btn.haptics_on":"Вибрация: ВКЛ",
      "btn.haptics_off":"Вибрация: ВЫКЛ",
      "account.need_login_delete": "Для удаления аккаунта необходимо войти в систему.",
      "account.reset_your_progress": "Вы действительно хотите сбросить прогресс? Это действие нельзя отменить.",
      "mosse.finite":"Ходов больше нет!",
      "ui.ok":"OK",
      "ui.confirm":"Подтвердить",
      "ui.cancel":"Отмена",
      "login.nickname_too_short": "Пожалуйста, введите ник не менее 3 символов.",
      "passkey.register_failed": "Регистрация passkey не удалась",
      "passkey.login_failed": "Ошибка входа с passkey",
      "error.new_game": "Ошибка при запуске новой игры",
      "hint.title":"Подсказка — предложенный ход",
      "hint.recharge":"Подсказки перезаряжаются каждые 3 уровня",
      "login.title":"Войти в игру",
      "login.nickname_ph":"Ник (мин 3 символа)",
      "login.passkey_login":"Войти с помощью Touch ID / Face ID",
      "login.passkey_register":"Создать passkey (без пароля)",
      "login.guest":"Играть без аккаунта",
      "login.note":"Примечание: на некоторых устройствах ник может быть необязательным для входа (discoverable passkeys).",
      "label.best_score":"Лучший счёт",
      "Ads1":"Закончились подсказки?",
      "Ads2":"Посмотри рекламу, чтобы получить 2 дополнительные подсказки :)",

      "Congratulations!": "Поздравляем! Вы прошли уровень",
      "prepare": "Рассчитываем следующий уровень...",
    },
    ja: {
      "label.level":"レベル",
      "label.grid":"グリッド",
      "label.moves":"手数",
      "label.score":"スコア",
      "btn.undo":"元に戻す",
      "btn.auto":"チュートリアル/オート",
      "btn.new":"新規",
      "btn.hint":"ヒント",
      "btn.ad_hints":"広告 +2 ヒント",
      "modal.account":"アカウント",
      "btn.close":"閉じる",
      "label.nickname":"ニックネーム",
      "label.username":"ユーザー名",
      "label.anim_speed":"アニメ速度",
      "note.anim_speed":"スクロールと破壊に影響。スターは同じです。",
      "btn.music_on":"音楽: ON",
      "btn.music_off":"音楽: OFF",
      "label.instant":"即時移動",
      "note.instant":"待ち時間なし：効果中でもスワイプ可能（アニメが途中で切れる場合あり）。",
      "label.relax":"リラックスモード",
      "note.relax":"3×3 / 5×5 のみ。7×7/10×10 なし（スコアは同じで難易度のみ）。",
      "label.user_id":"ユーザーID",
      "label.language":"言語",
      "btn.logout":"ログアウト",
      "btn.reset_progress":"進捗リセット",
      "btn.delete_account":"アカウント削除",
      "note.reset_delete":"注: 「進捗リセット」はこの端末のローカルのみ。 「アカウント削除」はバックエンドが必要（後で）。",
      "toast.new_game":"新しいゲーム",
      "confirm.new_game":"新しいゲームを開始しますか？現在のセーブは上書きされます。",
      "confirm.reset_progress":"この端末のローカル進捗をリセットしますか？",
      "confirm.delete_account":"本当によろしいですか？アカウントのデータはすべて削除されます。元に戻せません。",
      "stallo":"詰み！ UNDO を押して",
      "toast.reset_done":"進捗をリセットしました",
      "welcome.bonus_hints":"ウェルカムヒントはこちら：",
      "btn.haptics_on":"バイブ: ON",
      "btn.haptics_off":"バイブ: OFF",
      "account.need_login_delete": "アカウントを削除するにはログインが必要です。",
      "account.reset_your_progress": "本当に進捗をリセットしますか？この操作は元に戻せません。",
      "mosse.finite":"動きがなくなりました",
      "ui.ok":"OK",
      "ui.confirm":"確認",
      "ui.cancel":"キャンセル",
      "login.nickname_too_short": "ニックネームは3文字以上で入力してください。",
      "passkey.register_failed": "パスキーの登録に失敗しました",
      "passkey.login_failed": "パスキーのログインに失敗しました",
      "error.new_game": "新しいゲームの開始中にエラーが発生しました",
      "hint.title":"ヒント — 提示された手",
      "hint.recharge":"ヒントは3レベルごとにリセットされます",
      "login.title":"ゲームにサインイン",
      "login.nickname_ph":"ニックネーム（3文字以上）",
      "login.passkey_login":"指紋/Face IDでサインイン",
      "login.passkey_register":"パスキーを作成（パスワードなし）",
      "login.guest":"ゲストとしてプレイ",
      "login.note":"注: 一部のデバイスでは、ニックネームはログインにオプション（発見可能なパスキー）です。",
      "label.best_score":"最高スコア",
      "Ads1":"ヒントがなくなりましたか？",
      "Ads2":"広告を見て、2つの追加ヒントを獲得しましょう :)",

      "Congratulations!": "おめでとうございます！レベルをクリアしました",
      "prepare": "次のレベルを計算中…",
    },
    ar: {
      "label.level":"المستوى",
      "label.grid":"الشبكة",
      "label.moves":"الحركات",
      "label.score":"النقاط",
      "btn.undo":"تراجع",
      "btn.auto":"تعليم/تلقائي",
      "btn.new":"جديدة",
      "btn.hint":"تلميح",
      "btn.ad_hints":"إعلان +2 تلميحات",
      "modal.account":"الحساب",
      "btn.close":"إغلاق",
      "label.nickname":"اللقب",
      "label.username":"اسم المستخدم",
      "label.anim_speed":"سرعة الحركة",
      "note.anim_speed":"تؤثر على السحب والكسر. النجوم تبقى كما هي.",
      "btn.music_on":"الموسيقى: تشغيل",
      "btn.music_off":"الموسيقى: إيقاف",
      "label.instant":"حركة فورية",
      "note.instant":"بدون انتظار: يمكنك السحب أثناء المؤثرات (قد تُقصّ الحركة).",
      "label.relax":"وضع الاسترخاء",
      "note.relax":"فقط 3×3 / 5×5. بدون 7×7 أو 10×10 (النقاط لا تتغير، فقط الصعوبة).",
      "label.user_id":"معرّف المستخدم",
      "label.language":"اللغة",
      "btn.logout":"تسجيل الخروج",
      "btn.reset_progress":"إعادة ضبط التقدم",
      "btn.delete_account":"حذف الحساب",
      "note.reset_delete":"ملاحظة: “إعادة ضبط التقدم” تمسح فقط التقدم المحلي على هذا الجهاز. “حذف الحساب” يحتاج خادم (لاحقاً).",
      "toast.new_game":"لعبة جديدة",
      "confirm.new_game":"بدء لعبة جديدة؟ سيتم استبدال الحفظ الحالي.",
      "confirm.reset_progress":"هل تريد إعادة ضبط التقدم المحلي على هذا الجهاز؟",
      "confirm.delete_account":"هل أنت متأكد؟ سيتم حذف كل بيانات الحساب. إجراء غير قابل للتراجع.",
      "stallo":"عالق! اضغط تراجع",
      "toast.reset_done":"تمت إعادة ضبط التقدم",
      "welcome.bonus_hints":"هذه تلميحات الترحيب الخاصة بك:",
      "btn.haptics_on":"الاهتزاز: تشغيل",
      "btn.haptics_off":"الاهتزاز: إيقاف",
      "account.need_login_delete": "لحذف الحساب، يجب تسجيل الدخول أولاً.",
      "account.reset_your_progress": "هل تريد حقًا إعادة ضبط تقدمك؟ لا يمكن التراجع عن هذا الإجراء.",
      "mosse.finite":"لا مزيد من الحركات!",
      "ui.ok":"حسناً",
      "ui.confirm":"تأكيد",
      "ui.cancel":"إلغاء",
      "login.nickname_too_short": "يرجى إدخال لقب مكون من 3 أحرف على الأقل.",
      "passkey.register_failed": "فشل تسجيل مفتاح المرور",
      "passkey.login_failed": "فشل تسجيل مفتاح المرور",
      "error.new_game": "خطأ أثناء بدء لعبة جديدة",
      "hint.title":"تلميح — اليد المقترحة",
      "hint.recharge":"يتم إعادة تحميل التلميحات كل 3 مستويات",
      "login.title":"تسجيل الدخول",
      "login.nickname_ph":"الاسم المستعار (3 أحرف على الأقل)",
      "login.passkey_login":"تسجيل الدخول بالبصمة / Face ID",
      "login.passkey_register":"إنشاء Passkey (بدون كلمة مرور)",
      "login.guest":"اللعب كضيف",
      "login.note":"ملاحظة: في بعض الأجهزة قد يكون الاسم المستعار اختياريًا (Passkeys قابلة للاكتشاف).",
      "label.best_score":"أعلى نقاط",
      "Ads1":"نفدت التلميحات؟",
      "Ads2":"شاهد إعلانًا للحصول على 2 تلميحات إضافية :)",
      "Congratulations!": "تهانينا! لقد أكملت المستوى",
      "prepare": "...جارٍ حساب المستوى التالي",
    },
    zh: {
      "label.level":"关卡",
      "label.grid":"网格",
      "label.moves":"步数",
      "label.score":"得分",
      "btn.undo":"撤销",
      "btn.auto":"教程/自动",
      "btn.new":"新局",
      "btn.hint":"提示",
      "btn.ad_hints":"广告 +2 提示",
      "modal.account":"账户",
      "btn.close":"关闭",
      "label.nickname":"昵称",
      "label.username":"用户名",
      "label.anim_speed":"动画速度",
      "note.anim_speed":"影响滑动与破碎效果，星级不变。",
      "btn.music_on":"音乐：开",
      "btn.music_off":"音乐：关",
      "label.instant":"瞬间移动",
      "note.instant":"无需等待：效果播放中也可滑动（动画可能被截断）。",
      "label.relax":"轻松模式",
      "note.relax":"仅 3×3 / 5×5。无 7×7 或 10×10（分数不变，仅难度变化）。",
      "label.user_id":"用户ID",
      "label.language":"语言",
      "btn.logout":"退出登录",
      "btn.reset_progress":"重置进度",
      "btn.delete_account":"删除账户",
      "note.reset_delete":"注： “重置进度”只清除本设备本地进度。“删除账户”需要后端接口（稍后）。",
      "toast.new_game":"新游戏",
      "confirm.new_game":"开始新游戏？当前存档将被覆盖。",
      "confirm.reset_progress":"重置本设备的本地进度？",
      "confirm.delete_account":"确定吗？账户相关数据将被删除，且不可恢复。",
      "stallo":"卡住了！请按撤销",
      "toast.reset_done":"进度已重置",
      "welcome.bonus_hints":"这是你的欢迎提示：",
      "btn.haptics_on":"震动：开",
      "btn.haptics_off":"震动：关",
      "account.need_login_delete": "要删除账户，您需要先登录。",
      "account.reset_your_progress": "您真的要重置您的进度吗？此操作无法撤销。",
      "mosse.finite":"你已经没有招数了。",
      "ui.ok":"确定",
      "ui.confirm":"确认",
      "ui.cancel":"取消",
      "login.nickname_too_short": "请输入至少3个字符的昵称。",
      "passkey.register_failed": "Passkey注册失败",
      "passkey.login_failed": "通行密钥登录失败",
      "error.new_game": "新游戏时出错",
      "hint.title":"提示 — 推荐的移动",
      "hint.recharge":"提示每3级充能一次。",
      "login.title":"登录游戏",
      "login.nickname_ph":"昵称（至少3个字符）",
      "login.passkey_login":"使用指纹/面部ID登录",
      "login.passkey_register":"创建Passkey（无密码）",
      "login.guest":"以游客身份玩",
      "login.note":"注：在某些设备上，昵称对于登录可能是可选的（可发现的Passkeys）。",
      "label.best_score":"最高分",
      "Ads1":"提示用完了？",
      "Ads2":"观看广告以获得2个额外提示 :)",

      "Congratulations!": "恭喜！您已完成此關卡。",
      "prepare": "正在計算下一關…"
  } };

  const LANG_KEY = "psb_lang_v1";

  function normLang(code){
    const c = (code || "").toLowerCase();
    if (c.startsWith("it")) return "it";
    if (c.startsWith("en")) return "en";
    if (c.startsWith("fr")) return "fr";
    if (c.startsWith("de")) return "de";
    if (c.startsWith("es")) return "es";
    if (c.startsWith("ru")) return "ru";
    if (c.startsWith("ja")) return "ja";
    if (c.startsWith("ar")) return "ar";
    if (c.startsWith("zh")) return "zh";
    return "en";
  }

  function getLang(){
    const saved = localStorage.getItem(LANG_KEY);
    if (saved && I18N[saved]) return saved;
    // auto-detect only on first run
    const auto = normLang(navigator.language || (navigator.languages && navigator.languages[0]) || "en");
    localStorage.setItem(LANG_KEY, auto);
    return auto;
  }

  function setLang(lang){
    const l = I18N[lang] ? lang : "en";
    localStorage.setItem(LANG_KEY, l);
    applyI18n(l);
  }

  function t(key){
    const lang = getLang();
    return (I18N[lang] && I18N[lang][key]) || (I18N.it && I18N.it[key]) || key;
  }

  function applyI18n(lang){
    const l = I18N[lang] ? lang : "en";
    document.documentElement.lang = l === "zh" ? "zh" : l;
    document.documentElement.dir = (l === "ar") ? "rtl" : "ltr";

    document.querySelectorAll("[data-i18n]").forEach(el => {
      const k = el.getAttribute("data-i18n");
      if (!k) return;
      el.textContent = (I18N[l] && I18N[l][k]) || (I18N.it && I18N.it[k]) || el.textContent;
    });
    // translate placeholders
    document.querySelectorAll("[data-i18n-placeholder]").forEach(el => {
      const k = el.getAttribute("data-i18n-placeholder");
      if (!k) return;
      const val = (I18N[l] && I18N[l][k]) || (I18N.it && I18N.it[k]);
      if (val) el.setAttribute("placeholder", val);
    });

    // translate titles (optional, but useful)
    document.querySelectorAll("[data-i18n-title]").forEach(el => {
      const k = el.getAttribute("data-i18n-title");
      if (!k) return;
      const val = (I18N[l] && I18N[l][k]) || (I18N.it && I18N.it[k]);
      if (val) el.setAttribute("title", val);
    });

    // update dynamic button labels (music)
    if (typeof updateMusicButton === "function") updateMusicButton();
  }

  // ===== Custom UI dialog (replaces browser alert/confirm) =====

  let __uiDialogResolve = null;

  function uiDialogOpen({ title=null, msg="", mode="alert" }){
    const ov = document.getElementById("uiDialogOverlay");
    const elT = document.getElementById("uiDialogTitle");
    const elM = document.getElementById("uiDialogMsg");
    const btnX = document.getElementById("uiDialogX");
    const btnOk = document.getElementById("uiDialogOk");
    const btnCancel = document.getElementById("uiDialogCancel");

    // fallback estremo (non dovrebbe mai servire)
    if (!ov || !elT || !elM || !btnOk || !btnCancel || !btnX){
      if (mode === "confirm") return Promise.resolve(confirm(String(msg)));
      alert(String(msg));
      return Promise.resolve(true);
    }

    const tr = (k, fb) => (typeof t === "function" ? (t(k) || fb) : fb);

    elT.textContent = title || tr("Converge");
    elM.textContent = String(msg);
    elM.style.whiteSpace = "pre-line";

    const isConfirm = (mode === "confirm");
    btnCancel.style.display = isConfirm ? "" : "none";
    btnCancel.textContent = tr("ui.cancel", btnCancel.textContent || "Cancel");
    btnOk.textContent = isConfirm ? tr("ui.confirm", "Confirm") : tr("ui.ok", btnOk.textContent || "OK");

    ov.classList.add("show");
    ov.setAttribute("aria-hidden","false");

    const close = (val) => {
      ov.classList.remove("show");
      ov.setAttribute("aria-hidden","true");
      const r = __uiDialogResolve;
      __uiDialogResolve = null;
      if (r) r(val);
    };

    btnOk.onclick = () => close(true);
    btnCancel.onclick = () => close(false);
    btnX.onclick = () => close(false);
    ov.onclick = (e) => { if (e.target === ov) close(false); };

    return new Promise(resolve => { __uiDialogResolve = resolve; });
  }

  function uiAlert(msg, title=null){
    return uiDialogOpen({ title, msg, mode:"alert" });
  }

  function uiConfirm(msg, title=null){
    return uiDialogOpen({ title, msg, mode:"confirm" });
  }


  // === end i18n ===

  // === ADS ABSTRACTION (works on Web = no-op, works on APK once we wire AdMob) ===
  const Ads = (() => {
    let rewardedBusy = false;
    let lastRewardTs = 0;

    // Cooldown anti-spam: 60s tra rewarded (modifica se vuoi)
    const REWARD_COOLDOWN_MS = 60_000;

    function isNativeApp() {
      // Capacitor injects window.Capacitor in native builds
      return !!window.Capacitor;
    }

    async function init() {
      // In web: do nothing
      // In APK: we'll call the real AdMob init later
      if (isNativeApp() && typeof window.adsInitNative === "function") {
        await window.adsInitNative();
      }
    }

    async function showBanner() {
      if (isNativeApp() && typeof window.showBannerNative === "function") {
        await window.showBannerNative();
      }
    }

    async function hideBanner() {
      if (isNativeApp() && typeof window.hideBannerNative === "function") {
        await window.hideBannerNative();
      }
    }

    async function showRewardedFor2Hints() {
      const now = Date.now();
      if (rewardedBusy) return { ok:false, reason:"busy" };
      if (now - lastRewardTs < REWARD_COOLDOWN_MS) return { ok:false, reason:"cooldown" };

      rewardedBusy = true;
      try {
        // 1) Costruisci return URL (torni qui e aggiungi reward=2 dalla Activity)
        const returnUrl = location.origin + location.pathname + location.search + location.hash;

        // 2) Segna che stai aspettando un reward (anti-fake via URL manuale)
        localStorage.setItem("__cv_pending_reward", String(now));

        // 3) Apri la Activity nativa via deep link
        //    IMPORTANTE: deve matchare l'intent-filter che hai messo nel Manifest
        const deep = "converge://rewarded?return=" + encodeURIComponent(returnUrl);
        location.href = deep;

        // Qui non possiamo "attendere": la pagina naviga via deep link
        return { ok:true, reason:"launched" };
      } finally {
        rewardedBusy = false;
      }
    }


    return { init, showBanner, hideBanner, showRewardedFor2Hints };
  })();

  // === UI HOOK: Reward button gives +2 hints only if rewarded ===
  (function wireRewardButton() {
    const btn = document.getElementById("btnReward2Hints");
    if (!btn) return;
    btn.addEventListener("click", () => {
      // Apri sempre il popup (anche sul web), poi il bottone "Guarda" gestisce Ads.showRewardedFor2Hints()
      openReward?.();
    });
  })();

  (function consumeRewardFromUrl(){
    const p = new URLSearchParams(location.search);
    const reward = p.get("reward");
    if (!reward) return;

    // accetta solo se c'era un pending recente
    const ts = parseInt(localStorage.getItem("__cv_pending_reward") || "0", 10);
    localStorage.removeItem("__cv_pending_reward");

    const age = Date.now() - ts;
    const MAX_AGE_MS = 5 * 60 * 1000; // 5 min

    if (ts > 0 && age >= 0 && age <= MAX_AGE_MS && reward === "2") {
      // chiama la tua funzione esistente (già prevista nel codice)
      if (typeof onRewardedAdCompleted === "function") onRewardedAdCompleted();
      // opzionale: feedback UI
      try { console.log("Reward OK: +2 hints"); } catch(e){}
    }
    // pulizia URL: togli reward=2 per non poter refreshare e riprenderlo
    p.delete("reward");
    const newQs = p.toString();
    const newUrl = location.pathname + (newQs ? ("?" + newQs) : "") + location.hash;
    history.replaceState({}, "", newUrl);
  })();

</script>


<body>

<div class="app">
    <div class="topbar">
      <div class="topbar-head">
        <div class="title">
          <h1>Converge</h1>
          <div class="userbadge" id="userBadge" style="display:none;">
            Username: <strong id="userNickname"></strong>
          </div>
          <div class="sub">Swipe to merge tiles and break the grid</div>
        </div>

        <div class="topbar-icons">
          <button id="btnUndo" class="iconbtn icononly" aria-label="Undo" title="Undo">

            <img src="icons/restart.svg" alt="Restart" class="iconimg">

          </button>

          <div class="hint-btn-wrap">
              <button id="btnHint" class="iconbtn iconbtn-hint icononly" aria-label="Hint" title="Hint">
                <img src="icons/bulb.svg" alt="Hint" class="iconimg">
              </button>

            <span class="hint-badge" id="hintBadge">0</span>
          </div>

          <button class="iconbtn" id="btnAccount" title="Account / Impostazioni" aria-label="Account">
            <img src="icons/settings.svg" alt="Account" class="iconimg">
          </button>
        </div>
      </div>

      <div class="hud">

        <div class="hud-card hud-score">
          <div class="hud-label" data-i18n="label.score">Score</div>
          <div class="hud-value" id="score">0</div>
        </div>

          <div class="hud-card hud-best">
            <div class="hud-label" data-i18n="label.best_score">Highest<br>Score</div>
            <div class="hud-value" id="bestScore">0</div>
          </div>
        <div class="hud-card hud-moves">
          <div class="hud-label" data-i18n="label.moves">Mosse</div>
          <div class="hud-value" id="moves">2</div>
        </div>

         <!-- COLONNA 3: bottoni impilati -->

      <div class="hud-right">
        <button id="btnNew" class="iconbtn icononly" aria-label="New Game" title="New Game">
            <img src="icons/new.svg" alt="New" class="iconimg">
        </button>

          <button id="btnReward2Hints" class="iconbtn iconbtn-hint icononly" aria-label="2Hint" title="2Hint">

            <img src="icons/bulbads.svg" alt="Hint" class="iconimg">

          </button>
              <button id="btnAuto" class="iconbtn icononly" aria-label="Auto" title="Auto">
                <img src="icons/auto.svg" alt="Auto" class="iconimg">
              </button>

              </div>

        <div id="rewardOverlayStatus" class="small reward-status"></div>

        <div class="hud-card hud-size">
          <div class="hud-label" data-i18n="label.grid">Griglia</div>
          <div class="hud-value" id="size">3×3</div>
        </div>

      </div>



    </div>


    <div class="board-wrap">
      <div class="board" id="board">
        <div class="grid" id="grid"></div>
        <div class="tiles-layer" id="tiles"></div>
      </div>

      <div id="ad-banner-slot" class="ad-banner-slot" aria-label="Advertisement"></div>

    </div>
  </div>
  <div class="levelbar" aria-label="Level">
    <span data-i18n="label.level">Livello</span>
    <strong id="level">1</strong>
  </div>
    <div id="gameOverOverlay" class="gameover hidden">

      <!-- CARD INFORMATIVA -->
      <div class="gameover-card">
        <div class="gameover-title">Game Over</div>
        <div class="gameover-text" id="gameOverText" data-i18n="mosse.finite">Mosse finite</div>
      </div>

      <!-- BARRA AZIONI SEPARATA -->
      <div class="gameover-bar">
        <button id="btnGameOverUndo" class="btn">Undo</button>
        <button id="btnGameOverClose" class="btn secondary">Play Again</button>
      </div>

    </div>

    <!-- ACCOUNT OVERLAY (seconda pagina) -->
  <div class="modal-overlay hidden" id="accountOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <header>
        <h2 data-i18n="modal.account">Account</h2>
        <button id="btnCloseAccount" data-i18n="btn.close">Chiudi</button>
      </header>

      <div class="content">
        <div class="account-card">
          <div class="row">
            <div class="k" data-i18n="label.nickname">Nickname</div>
            <div class="v" id="accNickname">—</div>
          </div>
          <div class="row">
            <div class="k" data-i18n="label.username">Username</div>
            <div class="v" id="accUsername">—</div>
          </div>
          <div class="row" style="align-items:flex-start;">
            <div>
              <div class="k" style="margin-bottom:6px;" data-i18n="label.anim_speed">Velocità animazioni</div>
              <div class="settings-note" data-i18n="note.anim_speed">Influisce su scorrimento e rottura. Le stelline restano uguali.</div>
            </div>


            
            <div style="text-align:right; min-width:220px;">
              <input type="range" id="animSpeed" min="0.5" max="5.0" step="0.1" value="1" style="width:220px;">
              <div class="v" id="animSpeedVal" style="margin-top:6px;">1.0×</div>
            </div>

          </div>
            <div>
                <button id="btnMusic" data-i18n="btn.music_on">Music: ON</button>
                <button id="btnHaptics" data-i18n="btn.haptics_on" style="width:220px;">Haptics: ON</button>

            </div>
          <div class="row">
            <div>
              <div class="k" data-i18n="label.instant">Movimento istantaneo</div>
              <div class="settings-note" data-i18n="note.instant">Nessuna attesa: puoi scorrere anche mentre gli effetti sono in corso (l'animazione può essere tagliata).</div>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
              <label class="switch" title="Movimento istantaneo">
                <input type="checkbox" id="instantMode">
                <span class="slider"></span>
              </label>
            </div>
          </div>
          <div class="row">
            <div>
              <div class="k" data-i18n="label.relax">Relax mode</div>
              <div class="settings-note" data-i18n="note.relax">Solo griglie 3×3 / 5×5. Niente 7×7 o 10×10 (non cambia il punteggio, solo la difficoltà).</div>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
              <label class="switch" title="Relax mode">
                <input type="checkbox" id="relaxMode">
                <span class="slider"></span>
              </label>
            </div>

          </div>
          
          <div class="row">
            <div class="k" data-i18n="label.language">Lingua</div>
            <div style="text-align:right; min-width:220px;">
              <select id="langSelect" style="width:220px; padding:8px 10px; border-radius:12px;">
                <option value="it">Italiano</option>
                <option value="en">English</option>
                <option value="fr">Français</option>
                <option value="de">Deutsch</option>
                <option value="es">Español</option>
                <option value="ru">Русский</option>
                <option value="ja">日本語</option>
                <option value="ar">العربية</option>
                <option value="zh">中文</option>
              </select>
            </div>
          </div>

                  <div class="row">
            <div class="k" >Version 1.0.0 pre-release</div>
            <div class="v" id="accUserId">—</div>
          </div>
        </div>

        <div class="account-actions">
          <button id="btnAccountLogout" data-i18n="btn.logout">Logout</button>
          <button id="btnResetProgress" class="warn" data-i18n="btn.reset_progress">Reset progressi</button>
          <button id="btnDeleteAccount" class="danger" data-i18n="btn.delete_account">Elimina account</button>
        </div>

        <a style="display:block; margin-top:10px; text-align:center; color: white; " id="linkPrivacy" href="#">Privacy Policy</a>

      </div>
    </div>
  </div>





  <div class="toast" id="toast"></div>
  <div id="stalloMsg" class="stallo-msg hidden" data-i18n="stallo">STALLO! PREMERE UNDO</div>


  <div id="levelLoading" class="level-loading hidden" aria-hidden="true" data-mode="celebrate">
    <div class="level-loading-card">
      <img src="icons/yippee.gif" alt="Auto" class="iconimg">
      <div class="level-loading-title" id="levelLoadingTitle" data-i18n="Congratulations!">LIVELLO COMPLETATO!</div>
      <div class="level-loading-text" id="levelLoadingText" data-i18n="prepare">Preparando livello super difficile</div>
      <div class="spinner" id="levelLoadingSpinner" aria-hidden="true"></div>
    </div>
  </div>


  <div class="modal-overlay" id="hintOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <header>
        <h2 data-i18n="hint.title">Hint — mossa suggerita</h2>
        <button id="btnCloseHint" data-i18n="btn.close">Chiudi</button>
      </header>
      <div class="content">
        <div class="hint-board" id="hintCanvasWrap">
          <!-- mini-board generated -->
        </div>
        <p class="hint-text" id="hintText"></p>
        <div class="small hint-note" data-i18n="hint.recharge">L’hint si ricarica ogni 3 livelli.</div>
      </div>
    </div>
  </div>


    <div class="modal-overlay" id="hintHeavyOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <header>
        <h2>Hint — calcolo approfondito</h2>
        <button id="btnCloseHintHeavy">Chiudi</button>
      </header>

      <div class="content">
        <p class="hint-text" id="hintHeavyText">
          Questo livello richiede un calcolo più pesante per trovare una mossa vincente (o provare lo stallo).
          Vuoi procedere?
        </p>

        <div id="hintHeavySpinner" class="spinner hidden" aria-hidden="true"></div>

        <div style="display:flex; gap:10px; margin-top:12px;">
          <button id="btnHintHeavyGo">Voglio sapere</button>
          <button id="btnHintHeavyCancel" style="background: rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.18);">
            Annulla
          </button>
        </div>

        <div class="small" style="opacity:.8; margin-top:10px;">
          Se annulli, non consumi alcuna hint.
        </div>
      </div>
    </div>
  </div>

  <div class="login-overlay hidden" id="loginOverlay">
    <div class="login-modal">
      <h2 data-i18n="login.title">Sign in</h2>

      <input
        type="text"
        id="loginNickname"
        data-i18n-placeholder="login.nickname_ph"
        placeholder="Nickname (min 3 chars)"
      />

      <button id="btnPasskeyLogin" data-i18n="login.passkey_login">Sign in with Touch ID / Face ID</button>

      <button
        id="btnPasskeyRegister"
        data-i18n="login.passkey_register"
        style="background: var(--bg-1); margin-top: 8px;"
      >
        Create passkey (no password)
      </button>

      <button
        id="btnGuestPlay"
        data-i18n="login.guest"
        style="background: rgba(255,255,255,.1); border: 1px solid rgba(255,255,255,.2); margin-top: 8px; color: var(--text);"
      >
        Play as guest
      </button>

      <div class="small" data-i18n="login.note" style="margin-top:10px; color: rgba(16,20,24,.6); font-weight:700;">
        Note: on some devices nickname can be optional (discoverable passkeys).
      </div>
    </div>
  </div>


<script>
let GAME_SPEED = 1;          // 0.5 slow ... 5 fast
let INSTANT_MODE = false;    // true => no waits / no move blocking
let RELAX_MODE = false;      // true => only 3x3/5x5 levels


const UI_SETTINGS_KEY = "psb_ui_settings_v2";

function loadUiSettings(){
  try { return JSON.parse(localStorage.getItem(UI_SETTINGS_KEY) || "{}") || {}; }
  catch { return {}; }
}
function saveUiSettings(obj){
  try { localStorage.setItem(UI_SETTINGS_KEY, JSON.stringify(obj || {})); }
  catch {}
}

function clamp(n, lo, hi){ return Math.min(hi, Math.max(lo, n)); }

function setGameSpeed(v) {
  GAME_SPEED = clamp(Number(v) || 1, 0.5, 5.0);
  document.documentElement.style.setProperty("--anim-game", GAME_SPEED);
}

function setInstantMode(on){
  INSTANT_MODE = !!on;
  document.documentElement.classList.toggle("instant", INSTANT_MODE);
}

function setRelaxMode(on){
  RELAX_MODE = !!on;
  document.documentElement.classList.toggle("relax", RELAX_MODE);
}


(() => {
  "use strict";

  // ==========
  // Constants
  // ==========
  const SIZES = [3,5,7,10];
  const COLORS = [
    "#ffc8ba", // peach soft
    "#f5d4b8", // warm sand
    "#d4f0d4", // mint soft
    "#c8e6f5", // sky soft
    "#dcc8f5", // lavender soft
    "#f5c8e6", // rose soft
    "#e6f5c8", // pistachio soft
  ];

  // 7 glyphs for color-blind friendly: X, inner square, circle, triangle, equals, 5-point star, paw print
  // SVG strings are used for crisp scale.
  const GLYPHS = {
    0: svgX(),
    1: svgInnerSquare(),
    2: svgCircle(),
    3: svgTriangle(),
    4: svgEquals(),
    5: svgStar5(),
    6: svgPaw(),
  };

  const STORAGE_KEY = "psb_save_v1";

  // ==========
  // BGM (musica di sottofondo) - MINIMAL & SAFE
  // ==========
  const BGM_URL = "bgm.mp3";     // metti bgm.mp3 accanto a index.html (oppure cambia path)
  const BGM_DEFAULT_VOL = 0.08;  // 0.00..1.00 (0.08 = basso)

  const bgm = new Audio(BGM_URL);
  bgm.loop = true;
  bgm.preload = "auto";
  bgm.volume = BGM_DEFAULT_VOL;

  let bgmStarted = false;

  function startBgm(){
    if (!isBgmEnabled()) return;
    if (bgmStarted) return;

    const p = bgm.play();
    bgmStarted = true;

    if (p && typeof p.catch === "function"){
      p.catch(() => {
        bgmStarted = false;
      });
    }
  }

  function toggleBgm(){
    const enabled = !isBgmEnabled();
    setBgmEnabled(enabled);

    if (enabled){
      startBgm();
    } else {
      try { bgm.pause(); } catch(_) {}
      bgmStarted = false;
    }
    updateMusicButton();

  }



  // ==========
  // BGM SETTINGS (persistente)
  // ==========
  const BGM_ENABLED_KEY = "bgm_enabled";

  function isBgmEnabled(){
    const v = localStorage.getItem(BGM_ENABLED_KEY);
    return v === null ? true : v === "1"; // default: ON
  }

  function setBgmEnabled(v){
    localStorage.setItem(BGM_ENABLED_KEY, v ? "1" : "0");
  }
  function updateMusicButton(){
    if (!btnMusic) return;
    btnMusic.textContent = isBgmEnabled() ? t("btn.music_on") : t("btn.music_off");
  }


  // Avvia al primo input utente (mobile/desktop)
  window.addEventListener("pointerdown", startBgm, { once: true, capture: true });
  window.addEventListener("keydown", startBgm, { once: true, capture: true });

  // (Consigliato) Pausa se la tab va in background
  document.addEventListener("visibilitychange", () => {
    try{
      if (document.hidden){
        bgm.pause();
        bgmStarted = false;
      } else {
        startBgm();
      }
    } catch(_) {}
  });

// ==========
// Auth + API (Cloudflare Pages Functions)
// ==========

const ACCESS_TOKEN_KEY  = "psb_access_token_v1";
const REFRESH_TOKEN_KEY = "psb_refresh_token_v1";

function getAccessToken(){ return localStorage.getItem(ACCESS_TOKEN_KEY) || ""; }
function getRefreshToken(){ return localStorage.getItem(REFRESH_TOKEN_KEY) || ""; }

function setAnimSpeed(v) {
  setGameSpeed(v);
}


function setTokens({ access_token, refresh_token, token }) {
  const at = access_token || token || "";
  const rt = refresh_token || "";

  if (at) localStorage.setItem(ACCESS_TOKEN_KEY, at);
  if (rt) localStorage.setItem(REFRESH_TOKEN_KEY, rt);
}

function clearTokens(){
  localStorage.removeItem(ACCESS_TOKEN_KEY);
  localStorage.removeItem(REFRESH_TOKEN_KEY);
}

// backward compat helpers (minimo impatto sul resto del codice)
function getToken(){ return getAccessToken(); }
function setToken(t){ setTokens({ token: t }); }
function clearToken(){ clearTokens(); }
async function apiFetch(path, opts = {}) {
  const headers = { ...(opts.headers || {}) };

  const t = getAccessToken();
  if (t) headers["Authorization"] = "Bearer " + t;

  // se mando body, imposto content-type se manca
  if (opts.body && !headers["Content-Type"]) {
    headers["Content-Type"] = "application/json";
  }

  return fetch(path, { ...opts, headers });
}

async function apiPost(path, body){
  const headers = { "Content-Type": "application/json" };
  const t = getAccessToken();
  if (t) headers["Authorization"] = "Bearer " + t;


  const r = await fetch(path, {
    method: "POST",
    headers,
    body: JSON.stringify(body || {})
  });

  const data = await r.json().catch(() => ({}));
  if (!r.ok) throw new Error((data && (data.message || data.error)) || ("HTTP_"+r.status));
  return data;
}

async function doLogin(username, password){
  const { token } = await apiPost("/api/login", { username, password });
  setToken(token);
  await syncBonuses();
}


  document.getElementById("btn-logout")?.addEventListener("click", async () => {
    await logout();
  });

  document.getElementById("linkPrivacy")?.addEventListener("click", (e) => {
    e.preventDefault();
    openPrivacy();
  });


async function logout() {
  // Se hai un endpoint /logout è meglio chiamarlo:
 try {

    await apiFetch("/api/logout", { method: "POST" });

  } catch (_) {

    // fallback legacy (may 405 on static hosting)

    try { await apiFetch("/logout", { method: "POST" }); } catch (_) {}

  }

  clearTokens();
  clearNickname();
  // IMPORTANT: evita che lo scoped save del vecchio account venga riusato dopo logout
  try { localStorage.removeItem("psb_userkey_v1"); } catch {}
  try { window.currentUserKey = null; } catch {}

  try { bgm.pause(); } catch(_) {}
  bgmStarted = false;


  // Chiudi overlay aperti
  hideHint();
  closeAccount();

  // Mostra overlay login
  loginOverlay.classList.remove("hidden");

  // Aggiorna UI "guest"
  refreshUserUI().catch(() => {});
}


async function doRegister(username, password, referralCode){
  const { token } = await apiPost("/api/register", { username, password, referralCode });
  setToken(token);
  await syncBonuses();
}


async function syncBonuses() {
  // bonus una volta per device (anti-abuso semplice)
  if (localStorage.getItem("welcome_claimed_device") === "1") return;

  let c = null;
  try {
    c = await apiPost("/api/claim_initial", {});
  } catch (_) {
    // se offline o non loggato, non fare nulla
    return;
  }

  const granted = Number(c?.granted || 0);
  if (!Number.isFinite(granted) || granted <= 0) {
    // niente da dare: marca comunque come già gestito per evitare spam chiamate
    localStorage.setItem("welcome_claimed_device", "1");
    return;
  }

  // applica il bonus: porta almeno a "granted" (senza diminuire se già più alto)
  if (state) {
    const cur = Number(state.hintCharges || 0);
    if (cur < granted) {
      state.hintCharges = granted;
      state.hintCooldown = 0;
      saveNow();
    }
  }

  localStorage.setItem("welcome_claimed_device", "1");

  // messaggio benvenuto (no popup)
  toastMsg(`🎁 ${t?.("welcome.bonus_hints") || "Ecco i tuoi hint di benvenuto:"} ${granted}`);

  // 2) referral wallet -> converte in hint
  try {
    const w = await apiPost("/api/withdraw", {});
    const withdrawn = Number(w?.withdrawn || 0);
    if (withdrawn > 0 && state) {
      state.hintCharges += withdrawn;
      saveNow();
      toastMsg(`Bonus invitati: +${withdrawn} hint!`);
    }
  } catch (_) {
    // se fallisce withdraw, non bloccare il resto
  }
}



  const NICKNAME_KEY = "psb_nickname";

  function setNickname(n){
    if (!n) return;
    localStorage.setItem(NICKNAME_KEY, n);
    updateUserBadge();
  }

  function getNickname(){
    return localStorage.getItem(NICKNAME_KEY) || "";
  }

  function clearNickname(){
    localStorage.removeItem(NICKNAME_KEY);
    updateUserBadge();
  }

  function updateUserBadge(){
    const badge = document.getElementById("userBadge");
    const nickEl = document.getElementById("userNickname");
    if (!badge || !nickEl) return;

    const nick = getNickname();
    if (!nick){
      badge.style.display = "none";
      nickEl.textContent = "";
      return;
    }

    nickEl.textContent = nick;
    badge.style.display = "inline-flex";
  }


// ===== Account UI wiring + /me refresh =====
const accountOverlay = document.getElementById("accountOverlay");
const btnAccount = document.getElementById("btnAccount");
const btnCloseAccount = document.getElementById("btnCloseAccount");
const btnAccountLogout = document.getElementById("btnAccountLogout");
const btnResetProgress = document.getElementById("btnResetProgress");
const btnDeleteAccount = document.getElementById("btnDeleteAccount");

const accNicknameEl = document.getElementById("accNickname");
const accUsernameEl = document.getElementById("accUsername");
const accUserIdEl = document.getElementById("accUserId");
const btnLogout = document.getElementById("btnLogout");


function userStorageKey(baseKey){
  const uk = window.currentUserKey || localStorage.getItem("psb_userkey_v1") || "anon";
  return baseKey + ":" + uk;
}


function attachAccountButtons(){
  if (btnAccount) btnAccount.addEventListener("click", openAccount);
  if (btnCloseAccount) btnCloseAccount.addEventListener("click", closeAccount);
  if (btnAccountLogout) btnAccountLogout.addEventListener("click", () => { logout(); closeAccount(); });

  if (btnResetProgress) btnResetProgress.addEventListener("click", async () => {
    if (!(await uiConfirm(t("account.reset_your_progress")))) return;
    localStorage.removeItem(userStorageKey(STORAGE_KEY));
    if (!getAccessToken()) localStorage.removeItem(STORAGE_KEY); // solo per guest legacy

    state = newGameState();
    void startLevel(1);
    toastMsg(t("toast.reset_done") || "Progressi resettati");
    toastMsg("Progressi locali resettati");
    renderAll(true);
    saveNow();
    closeAccount();
  });

  const ENABLE_REAL_DELETE = true; // <-- quando avrai endpoint vero, metti true

  btnDeleteAccount?.addEventListener("click", async () => {
    const msg = ENABLE_REAL_DELETE
      ? (t("confirm.delete_account") || "Sei sicuro? Tutti i dati associati al tuo account saranno eliminati. Azione irreversibile.")
      : (t("confirm.delete_account_sim") || "ATTENZIONE: questa azione SIMULA l'eliminazione dell'account. Nessun dato verrà cancellato dal server. Vuoi continuare?");

    if (!(await uiConfirm(msg))) return;

    btnDeleteAccount.disabled = true;

    try {
      // Chiudi overlay aperti (ordine sicuro)
      try { hideHint(); } catch {}
      try { closeAccount(); } catch {}

      if (ENABLE_REAL_DELETE) {
        const token = localStorage.getItem("psb_access_token_v1") || localStorage.getItem("psb_token_v1") || "";
        if (token.length < 20) {
          await uiAlert(
            t("account.need_login_delete"));
          return;
        }

        // Endpoint vero (quando lo implementi)
        await apiPost("/api/delete_account", {});
      } else {
        // Facoltativo e NON distruttivo
        try { await apiFetch("/logout", { method: "POST" }); } catch {}
        try { await apiFetch("/api/logout", { method: "POST" }); } catch {}
      }

      // Cleanup client-side (sempre)
      try { clearTokens(); } catch {}
      try { clearNickname(); } catch {}
      try { localStorage.removeItem(userStorageKey(STORAGE_KEY)); } catch {}
      try { localStorage.removeItem(STORAGE_KEY); } catch {} // pulizia legacy


      // Torna al login in modo deterministico
      try {
        if (typeof showLoginScreen === "function") showLoginScreen();
        else {
          // fallback minimale: mostra overlay login e reset UI
          try { loginOverlay?.classList.remove("hidden"); } catch {}
        }
      } catch {}


      toastMsg(ENABLE_REAL_DELETE ? "Account eliminato" : "Account disconnesso + reset locale (test)");
    } catch (e) {
      const em = String(e?.message || e);

        if (em.toLowerCase().includes("unauthorized") || em.includes("HTTP_401")) {
          await uiAlert(t("account.need_login_delete") || "Devi effettuare il login per eliminare l’account.");
        } else if (em.includes("Failed to fetch")) {
          await uiAlert(t("net.failed_fetch") || "Connessione non disponibile o server irraggiungibile.");
        } else {
          await uiAlert((t("op.failed") || "Operazione fallita") + ": " + em);
        }

    } finally {
      btnDeleteAccount.disabled = false;
    }
  });


  if (accountOverlay){
    // click outside modal closes
    accountOverlay.addEventListener("click", (e) => {
      if (e.target === accountOverlay) closeAccount();
    });
  }

  // ESC closes overlays
  document.addEventListener("keydown", (e) => {
    if (e.key !== "Escape") return;
    hideHint();
    closeAccount();
  });
}

function openAccount(){
  if (!accountOverlay) return;
  refreshUserUI().catch(() => {});
  accountOverlay.classList.add("show");
  syncHapticsButton();
  accountOverlay.setAttribute("aria-hidden","false");
}

function closeAccount(){
  if (!accountOverlay) return;
  accountOverlay.classList.remove("show");
  syncHapticsButton();
  accountOverlay.setAttribute("aria-hidden","true");
}

async function fetchMe(){
  // Try both /me and /api/me to be robust
  const candidates = ["/me", "/api/me"];
  for (const path of candidates){
    try{
      const r = await apiFetch(path, { method: "GET" });
      if (!r.ok) continue;
      return await r.json().catch(() => null);
    }catch(_){}
  }
  return null;
}

async function refreshUserUI(){
  const logged = !!getAccessToken();

  // Defaults
  if (accNicknameEl) accNicknameEl.textContent = "—";
  if (accUsernameEl) accUsernameEl.textContent = "—";
  if (accUserIdEl) accUserIdEl.textContent = "—";

  if (!logged){
    updateUserBadge(); // will hide badge if nickname missing
    return;
  }

  const me = await fetchMe();

  // Normalize shape
  const u = (me && (me.user || me)) || {};
  const username = (u.username || me?.username || "").trim();
  const nickname = (u.nickname || me?.nickname || "").trim();
  const id = (u.id ?? me?.id ?? u.user_id ?? me?.user_id ?? "").toString();

  // === IMPORTANT: set user key for per-account local saves ===
  // Preferisci un identificatore stabile (id/username/nickname dal server).
  // Se /me non esiste o torna vuoto, NON sovrascrivere una chiave già salvata (es. pk:<credentialId>).
  const existingKey = (localStorage.getItem("psb_userkey_v1") || "").trim();
  const userKey =
    (id && ("id:" + id)) ||
    (username && ("u:" + username)) ||
    (nickname && ("n:" + nickname)) ||
    (existingKey ? existingKey : "auth");

  window.currentUserKey = userKey;
  try { localStorage.setItem("psb_userkey_v1", userKey); } catch {}
// Prefer username for badge and account display
  const badgeName = username || nickname || getNickname() || "—";

  // Store for badge (re-uses nickname storage key)
  if (badgeName && badgeName !== "—") setNickname(badgeName);

  // Update top-left badge
  updateUserBadge();

  // Update account modal fields
  if (accNicknameEl) accNicknameEl.textContent = nickname || "—";
  if (accUsernameEl) accUsernameEl.textContent = username || badgeName || "—";
  if (accUserIdEl) accUserIdEl.textContent = id || "—";
}

  // ==========
  // State
  // ==========
  /**
   * board[y][x] = null | tileId
   * tilesById[tileId] = { id, colorId, x, y }
   */
  let state = null;
  // ===== Rewarded Ads hook: give hints safely =====
  window.addHints = function addHints(n){
    n = Math.floor(Number(n) || 0);
    if (n <= 0) return;

    // se lo state non è pronto (es. prima di startGame), ignora
    if (!state) return;

    // aggiungi hint
    if (!Number.isFinite(state.hintCharges)) state.hintCharges = 0;
    state.hintCharges += n;

    // se avevi cooldown attivo ma ora hai hint, rendili subito utilizzabili
    if (state.hintCharges > 0) state.hintCooldown = 0;

    // se eri in "impossible" non bloccare gli hint a livello UI
    state.impossible = false;

    try { saveNow(); } catch(_) {}
    try { updateButtons(); } catch(_) {}
    try { toastMsg(`+${n} hint!`); } catch(_) {}
  };

  let isAnimating = false;
  let MOVE_TOKEN = 0; // used to cancel in-flight animations when instant mode is enabled
  let lastToastAt = 0;

  // ===== Performance tuning (mobile default) =====
  let LAST_CELL_W = 0;
  let LAST_CELL_H = 0;

  const IS_COARSE = matchMedia("(pointer: coarse)").matches;

  // su mobile attiva lowgfx automaticamente (puoi poi fare un toggle nelle impostazioni)
  if (IS_COARSE) document.documentElement.classList.add("lowgfx");

  // particelle: mobile meno, desktop di più
  const BREAK_PARTICLES = IS_COARSE ? 7 : 14;

  let stalloShown = false;

  // ===== AUTO / Tutorial mode =====
  let AUTO_MODE = false;
  let autoReturnSnapshot = null; // snapshot della partita "vera" per ripristino post-tutorial
  let autoLoopRunning = false;
  let autoStop = false;

  // se vuoi velocità senza animazioni pesanti:
  const AUTO_STEP_DELAY_MS = 60; // 0..200 a piacere


  // ==========
  // DOM
  // ==========
  const elGrid = document.getElementById("grid");
  const elTiles = document.getElementById("tiles");
  const elBoard = document.getElementById("board");

  const elLevel = document.getElementById("level");
  const elSize = document.getElementById("size");
  const elMoves = document.getElementById("moves");
  const elScore = document.getElementById("score");
  const elBestScore = document.getElementById("bestScore");

  const btnUndo = document.getElementById("btnUndo");
  const btnHint = document.getElementById("btnHint");
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const btnGameOverUndo = document.getElementById("btnGameOverUndo");
  const btnGameOverClose = document.getElementById("btnGameOverClose");
  const hintBadge = document.getElementById("hintBadge");

  function updateHintBadge(){
    if (!hintBadge) return;
    const n = Math.max(0, Number(state?.hintCharges ?? 0));
    hintBadge.textContent = (n > 99) ? "99+" : String(n);
    hintBadge.style.display = "inline-flex"; // sempre visibile
  }

  const btnNew  = document.getElementById("btnNew");

  const toast = document.getElementById("toast");
  

  // ===== Rewarded +2 hints overlay =====
  const rewardOverlay = document.getElementById("rewardOverlay");
  const btnReward2Hints = document.getElementById("btnReward2Hints");
  const btnRewardWatch = document.getElementById("btnRewardWatch");
  const btnRewardCancel = document.getElementById("btnRewardCancel");
  const rewardOverlayStatus = document.getElementById("rewardOverlayStatus");
  const rewardTopStatus = document.getElementById("rewardTopStatus");

  function openReward(){
    if (!rewardOverlay) return;
    rewardOverlay.classList.remove("hidden");
    rewardOverlay.setAttribute("aria-hidden","false");
    if (rewardOverlayStatus) rewardOverlayStatus.textContent = "";
    btnRewardWatch?.focus();
  }

  function closeReward(){
    if (!rewardOverlay) return;
    rewardOverlay.classList.add("hidden");
    rewardOverlay.setAttribute("aria-hidden","true");
  }

  // Apri overlay dal bottone "AD +2 hint"
  btnReward2Hints?.addEventListener("click", openReward);
  btnRewardCancel?.addEventListener("click", closeReward);

  btnRewardWatch?.addEventListener("click", async () => {
    try{
      btnRewardWatch.disabled = true;
      if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Caricamento…";

      const r = await Ads.showRewardedFor2Hints();

      if (r && r.ok && r.rewarded) {
        // +2 hint: usa la tua funzione esistente
        if (typeof onRewardedAdCompleted === "function" && state) onRewardedAdCompleted();
        if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Ok! +2 hint aggiunti.";
        closeReward();
      } else {
        const reason = r?.reason || "no_reward";
        if (reason === "web_no_ads") {
          if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Disponibile solo nell’app Android.";
        } else if (reason === "cooldown") {
          if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Riprova tra poco.";
        } else if (reason === "busy") {
          if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Attendi…";
        } else {
          if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Pubblicità non disponibile ora.";
        }
      }
    } catch(e){
      if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Errore: " + (e?.message || e);
    } finally {
      if (btnRewardWatch) btnRewardWatch.disabled = false;
    }
  });

  const rewardStatus = document.getElementById("rewardStatus");
  // ===== Offline overlay (solo UI; il gioco resta online-only) =====
  const offlineOverlay = document.getElementById("offlineOverlay");
  const btnOfflineRefresh = document.getElementById("btnOfflineRefresh");

  function showOffline(){
    if (!offlineOverlay) return;
    offlineOverlay.classList.remove("hidden");
  }
  function hideOffline(){
    if (!offlineOverlay) return;
    offlineOverlay.classList.add("hidden");
  }

  // Mostra subito se la pagina viene servita dalla cache ma la rete è giù
  if (typeof navigator !== "undefined" && navigator && navigator.onLine === false) showOffline();

  window.addEventListener("offline", () => showOffline());
  window.addEventListener("online", () => hideOffline());

  btnOfflineRefresh?.addEventListener("click", () => {
    // tenta un reload: se torna la rete, riparte; se no resta qui
    location.reload();
  });



  function openReward(){
    if (!rewardOverlay) return;
    rewardStatus.textContent = "";
    rewardOverlay.classList.remove("hidden");
  }
  function closeReward(){
    if (!rewardOverlay) return;
    rewardOverlay.classList.add("hidden");
  }

  btnRewardCancel?.addEventListener("click", closeReward);

  btnRewardWatch?.addEventListener("click", async () => {
    btnRewardWatch.disabled = true;
    rewardStatus.textContent = "";

    // Qui chiamiamo la rewarded (web fallback: dirà "Disponibile nell’app")
    const r = await Ads.showRewardedFor2Hints();

    if (r.ok && r.rewarded) {
      window.addHints?.(2);   // usa la funzione che aumenta state.hintCharges
      updateButtons();
      closeReward();
    } else {
      if (r.reason === "web_no_ads") rewardStatus.textContent = "Disponibile nell’app Android.";
      else if (r.reason === "cooldown") rewardStatus.textContent = "Riprova tra poco.";
      else rewardStatus.textContent = "Pubblicità non disponibile ora.";
    }

    btnRewardWatch.disabled = false;
  });

  const loginOverlay = document.getElementById("loginOverlay");
  const btnPasskeyLogin = document.getElementById("btnPasskeyLogin");
  const btnPasskeyRegister = document.getElementById("btnPasskeyRegister");
  const loginNickname = document.getElementById("loginNickname");

  const btnGuestPlay = document.getElementById("btnGuestPlay");


  const hintOverlay = document.getElementById("hintOverlay");
  const btnCloseHint = document.getElementById("btnCloseHint");
  const hintCanvasWrap = document.getElementById("hintCanvasWrap");
  const hintText = document.getElementById("hintText");


  document.getElementById("btnCloseHintHeavy")?.addEventListener("click", closeHintHeavyPrompt);
  document.getElementById("btnHintHeavyCancel")?.addEventListener("click", closeHintHeavyPrompt);
  document.getElementById("btnHintHeavyGo")?.addEventListener("click", runHeavyHint);

  const animSpeedInput = document.getElementById("animSpeed");
  const btnMusic = document.getElementById("btnMusic");
  btnMusic?.addEventListener("click", toggleBgm);
  const btnHaptics = document.getElementById("btnHaptics");
  btnHaptics?.addEventListener("click", toggleHaptics);
  const animSpeedVal   = document.getElementById("animSpeedVal");
  const instantModeInput = document.getElementById("instantMode");
  const relaxModeInput = document.getElementById("relaxMode");

  
  // FX (stelline) a velocità costante
  function applyFxSpeed(){
    // In manual a velocità normali resta “bella” e costante.
    // In AUTO o quando vai veloce, accelera l’FX così non si accumula e non lagga.
    const fx = (typeof AUTO_MODE !== "undefined" && AUTO_MODE) || GAME_SPEED >= 1.6 ? GAME_SPEED : 1;
    document.documentElement.style.setProperty("--anim-fx", fx);
  }
  applyFxSpeed();


  // Carica impostazioni UI salvate (velocità + modalità istantanea)
  const savedUI = loadUiSettings();
  const savedSpeed = clamp(parseFloat(savedUI.gameSpeed ?? savedUI.animSpeed ?? 1) || 1, 0.5, 5.0);
  const savedInstant = !!savedUI.instantMode;
  const savedRelax = !!savedUI.relaxMode;

  setGameSpeed(savedSpeed);
  setInstantMode(savedInstant);
  setRelaxMode(savedRelax);

  if (animSpeedVal) animSpeedVal.textContent = savedSpeed.toFixed(1) + "×";
  if (animSpeedInput) animSpeedInput.value = String(savedSpeed.toFixed(1));
  if (instantModeInput) instantModeInput.checked = savedInstant;
  if (relaxModeInput) relaxModeInput.checked = savedRelax;

  function persistUI(){
    saveUiSettings({ gameSpeed: GAME_SPEED, instantMode: INSTANT_MODE, relaxMode: RELAX_MODE });
  }

  if (animSpeedInput) {
    animSpeedInput.addEventListener("input", () => {
      const v = clamp(parseFloat(animSpeedInput.value) || 1, 0.5, 5.0);
      if (animSpeedVal) animSpeedVal.textContent = v.toFixed(1) + "×";
      setGameSpeed(v);
      applyFxSpeed();
      persistUI();
    });
  }

  if (instantModeInput){
    instantModeInput.addEventListener("change", () => {
      setInstantMode(instantModeInput.checked);
      persistUI();
    });
  }

  if (relaxModeInput){
    relaxModeInput.addEventListener("change", () => {
      setRelaxMode(relaxModeInput.checked);
      persistUI();
    });
  }
  

  // ==========
  // Boot
  // ==========
  // IMPORTANT: aspetta che il DOM sia completo (serve per overlay che stanno a fine pagina: rewardOverlay, offlineOverlay, ecc.)
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init, { once: true });
  } else {
    init();
  }

  function init(){
    try { Ads?.init?.(); } catch {}
    // i18n boot
    const _lang = getLang();
    applyI18n(_lang);

    attachLoginButtons();
    attachAccountButtons();

    // language selector
    const langSelect = document.getElementById("langSelect");
    if (langSelect) {
      langSelect.value = getLang();
      langSelect.addEventListener("change", () => setLang(langSelect.value));
    }

    updateMusicButton();
    attachButtons();
    
    
    // se ho un token salvato, provo a sincronizzare bonus e partire
    if (getAccessToken()){
      (async () => {
        await refreshUserUI().catch(() => {});
        startGame();
        syncBonuses().catch(() => {});
      })();
      return;
    }



    // altrimenti mostra login
    loginOverlay.classList.remove("hidden");
  }


    function startGame(){
    // Hide login overlay
    loginOverlay.classList.add("hidden");
    startBgm();

    // Try load save (scoped per-account)
    const loaded = loadSave();
    const loadedOk = !!(loaded && loaded.tilesById && Object.keys(loaded.tilesById).length > 0 && Array.isArray(loaded.board));

    if (loadedOk){
      state = loaded;
      toastMsg("Partita caricata");
    } else {
      state = newGameState();
      void startLevel(1); // genera board + render + save
    }

    // input & UI (sempre)
    attachInput();

    // Se abbiamo caricato un save valido, render/salva qui. Se abbiamo appena fatto startLevel(1) è già ok.
    if (loadedOk){
      renderAll(true);
      saveNow();
    }

    refreshUserUI().catch(() => {});
    updateUserBadge();
  }

  async function passkeyRegister(nickname, referralCode){
    const r1 = await apiPost("/api/passkey_register_begin", { nickname, referralCode });
    const cred = await navigator.credentials.create({ publicKey: pkCreateFromJSON(r1.options) });
    // Per-salvataggi locali: lega la chiave all'ID della passkey (stabile)
    try {
      const pkId = (cred && cred.id) ? String(cred.id) : "";
      if (pkId){
        const uk = "pk:" + pkId;
        window.currentUserKey = uk;
        localStorage.setItem("psb_userkey_v1", uk);
      }
    } catch {}

    const r2 = await apiPost("/api/passkey_register_finish", { nickname, credential: credToJSON(cred) });
    setToken(r2.token);

    // nickname: prima quello dal server, altrimenti quello inserito
    setNickname((r2 && r2.nickname) || nickname);

    await syncBonuses();

  }

  async function passkeyLogin(nicknameOptional){
    const r1 = await apiPost("/api/passkey_login_begin", { nickname: nicknameOptional || "" });
    const cred = await navigator.credentials.get({ publicKey: pkGetFromJSON(r1.options) });
    // Per-salvataggi locali: lega la chiave all'ID della passkey usata (stabile)
    try {
      const pkId = (cred && cred.id) ? String(cred.id) : "";
      if (pkId){
        const uk = "pk:" + pkId;
        window.currentUserKey = uk;
        localStorage.setItem("psb_userkey_v1", uk);
      }
    } catch {}

    const r2 = await apiPost("/api/passkey_login_finish", { nickname: nicknameOptional || "", credential: credToJSON(cred) });
    setToken(r2.token);

    // nickname: server > input
    setNickname((r2 && r2.nickname) || (nicknameOptional || ""));

    await syncBonuses();

  }



  function attachLoginButtons(){
    btnGuestPlay.addEventListener("click", () => {
      // Forza salvataggi "ospite" separati da quelli autenticati
      try { window.currentUserKey = "anon"; localStorage.setItem("psb_userkey_v1","anon"); } catch {}
      startGame();
    });
btnPasskeyRegister.addEventListener("click", async () => {
      const nickname = loginNickname.value.trim();
      if (!nickname || nickname.length < 3) {
        await uiAlert(t("login.nickname_too_short") || "Inserisci un nickname (min 3 caratteri)");
        return;
      }

      try{
        // referralCode per ora null (poi lo aggiungiamo se vuoi)
        const referralCode = null;
      await passkeyRegister(nickname, referralCode);
      await refreshUserUI().catch(() => {});
      startGame();

      } catch (e){
        await uiAlert((t("passkey.register_failed") || "Registrazione passkey fallita") + ": " + (e?.message || e));
      }
    });



    btnPasskeyLogin.addEventListener("click", async () => {
     
      const nickname = loginNickname.value.trim(); // può anche essere vuoto

      try{
        await passkeyLogin(nickname);
        await refreshUserUI().catch(() => {});
        startGame();

      } catch (e){
        console.error("Login passkey fallito:", e);
        if (!String(e?.message || "").includes("credential not found")) {
            await uiAlert((t("passkey.login_failed") || "Login passkey fallito") + ": " + (e?.message || e));
          }

      }
    });
  }


  async function submitHighScoreIfLoggedIn(score){
    if (!getAccessToken()) return; // guest/offline: non manda nulla
    try{
      await apiPost("/api/score_submit", { score });
    }catch(_){
        if (String(e?.message || "").includes("HTTP_401")) {
          // token non valido: riallinea lo stato (guest)
          clearTokens?.();
          // opzionale: aggiorna UI login
          refreshUserUI?.();
        }
      // ignora: rete assente ecc.
    }
  }



  function b64uToBuf(b64url){
    if (b64url instanceof ArrayBuffer) return b64url;
    if (ArrayBuffer.isView(b64url)) return b64url.buffer;

    const pad = "=".repeat((4 - (b64url.length % 4)) % 4);
    const b64 = (b64url + pad).replace(/-/g, "+").replace(/_/g, "/");
    const bin = atob(b64);

    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  }

  function deepCopy(obj){
    // options JSON -> clone sicuro
    if (typeof structuredClone === "function") return structuredClone(obj);
    return JSON.parse(JSON.stringify(obj));
  }

  function pkCreateFromJSON(optionsJSON){
    const pk = deepCopy(optionsJSON);

    // challenge: string -> ArrayBuffer
    if (typeof pk.challenge === "string") pk.challenge = b64uToBuf(pk.challenge);

    // user.id: string -> ArrayBuffer
    if (pk.user && typeof pk.user.id === "string") pk.user.id = b64uToBuf(pk.user.id);

    // excludeCredentials[].id: string -> ArrayBuffer
    if (Array.isArray(pk.excludeCredentials)) {
      pk.excludeCredentials = pk.excludeCredentials.map(c => ({
        ...c,
        id: (typeof c.id === "string") ? b64uToBuf(c.id) : c.id
      }));
    }

    return pk;
  }

  function pkGetFromJSON(optionsJSON){
    const pk = deepCopy(optionsJSON);

    // challenge: string -> ArrayBuffer
    if (typeof pk.challenge === "string") pk.challenge = b64uToBuf(pk.challenge);

    // allowCredentials[].id: string -> ArrayBuffer
    if (Array.isArray(pk.allowCredentials)) {
      pk.allowCredentials = pk.allowCredentials.map(c => ({
        ...c,
        id: (typeof c.id === "string") ? b64uToBuf(c.id) : c.id
      }));
    }

    return pk;
  }

  function credToJSON(cred){
    if (!cred) return null;

    // id DEVE corrispondere a rawId (base64url)
    const rid = bufToB64u(cred.rawId);

    const obj = {
      id: rid,
      rawId: rid,
      type: cred.type,
      clientExtensionResults: cred.getClientExtensionResults?.() || {},
      transports: cred.response?.getTransports?.() || [],
      response: {}
    };

    const r = cred.response;
    if (r.attestationObject) obj.response.attestationObject = bufToB64u(r.attestationObject);
    if (r.clientDataJSON) obj.response.clientDataJSON = bufToB64u(r.clientDataJSON);

    // login fields (per assertion)
    if (r.authenticatorData) obj.response.authenticatorData = bufToB64u(r.authenticatorData);
    if (r.signature) obj.response.signature = bufToB64u(r.signature);
    if (r.userHandle) obj.response.userHandle = bufToB64u(r.userHandle);

    return obj;
  }

  function bufToB64u(buf){
    const bytes = new Uint8Array(buf);
    let bin = "";
    bytes.forEach(b => bin += String.fromCharCode(b));
    return btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,"");
  }


  // ==========
  // Game state
  // ==========
  function newGameState(){
    return {
      level: 1,
      last_reward_level: 0,
      sizeIndex: 0,
      N: SIZES[0],
      score: 0,
      moves: 3,
      undoAvailable: true,
      hintCharges: 1, // 1 per 3 livelli (we track cooldown)
      hintCooldown: 0, // levels until recharge (0 means available if charges>0)
      impossible: false, // solver proved no solution from current state (=> suggest Undo)

      // generation seed-ish
      rngSeed: Math.floor(Math.random()*1e9) >>> 0,
      // board data
      board: [],
      tilesById: {},
      nextTileId: 1,
      // snapshot for undo
      undoSnapshot: null,
      // solver path for the current level (optional; we store a precomputed best direction)
      levelPlan: {
        // We keep it minimal: a list of recommended directions; for demo we compute first move by solver.
        bestFirstDir: null,
      }
    };
  }

  function weightedPickGrid(){
  // Puoi cambiare i pesi. Qui evito 10x10 troppo spesso.
  const bag = [3,3,3, 5,5,5,5, 7,7, 10]; // 3:30% 5:40% 7:20% 10:10%
  return bag[Math.floor(Math.random() * bag.length)];
  }

  function pickGridSizeForLevel(level){

    if (RELAX_MODE) {
      // In relax mode, mantieni 3x3 o 5x5 per sempre
      return (Math.random() < 0.35) ? 3 : 5;
    }
    if (level < 5) {
      // lascia la tua progressione attuale (o come preferisci)
      // esempio: 1-3 => 3, 4 => 5
      return (level <= 3) ? 3 : 5;
    }
    return weightedPickGrid();
  }

  function pickGridSizeForLevelConsideringMoves(level, moves){
    const base = pickGridSizeForLevel(level);
    const m = Math.max(0, Number(moves) || 0);

    let cap;
    if (RELAX_MODE) cap = 5;
    else if (m <= 5) cap = 3;
    else if (m <= 11) cap = 5;
    else if (m <= 19) cap = 7;
    else cap = 10;

    return Math.min(base, cap);
  }


  function regenCleanLevel(){
    // “pulito” = stesso livello ma board rigenerata
    // Se la tua startLevel già rigenera la board, basta richiamarla.
    startLevel(state.level);
  }


  async function startLevel(nextLevel){
    stalloShown = false;
    stopPulseUndoButton();

    state.level = nextLevel;
    // Reward: +10 hint at levels 10,20,40,80...
    const reward = checkLevelReward(state.level);
    if (reward > 0 && state.last_reward_level < state.level) {
      state.hintCharges += reward;
      state.last_reward_level = state.level;
    }

    // ===== Level reward: +10 hint at levels 10,20,40,80,160...
    if (!Number.isFinite(state.last_reward_level)) state.last_reward_level = 0;

    if (reward > 0 && state.last_reward_level < state.level) {
      if (!Number.isFinite(state.hintCharges)) state.hintCharges = 0;
      state.hintCharges += reward;
      state.last_reward_level = state.level;

      // se eri a 0 e avevi cooldown, rendilo subito usabile
      if (state.hintCharges > 0) state.hintCooldown = 0;

      toastMsg(`+${reward} HINT UNLOCKED`);
    }



    // Le mosse NON si resettano: si accumulano tra i livelli.
    // Garantiamo solo un minimo per evitare soft-lock a 0.
    state.moves = Math.max(state.moves, 3);
    if (RELAX_MODE) state.moves = Math.max(state.moves, 5);
    state.N = pickGridSizeForLevelConsideringMoves(nextLevel, state.moves);
    // Sync sizeIndex <-> N per evitare mismatch 5x5 vs 3x3
    state.sizeIndex = Math.max(0, SIZES.indexOf(state.N));


    state.undoAvailable = true;
    state.undoSnapshot = null;
    state.impossible = false;

    // hint recharge every 3 levels
    if (state.hintCooldown > 0) state.hintCooldown -= 1;
    if (state.hintCooldown === 0 && state.hintCharges === 0) {
      state.hintCharges = 1;
    }

    // regen board with at least 1 empty, each color >=2
    
    await generateLevelBoardGated();


    // compute best first dir as a "plan" (demo-level).
    state.levelPlan.bestFirstDir = computeHintDirectionForCurrentState({maxDepth: 6, timeBudgetMs: 25});

    saveNow();
    renderAll(true);
    toastMsg(`Livello ${state.level}`);
  }

  function levelToSizeIndex(level){
    if (level <= 3) return 0; // 3
    if (level <= 7) return 1; // 5
    if (level <= 12) return 2; // 7
    return 3; // 10
  }

  // ==========
  // Generation (minimal but consistent)
  // ==========
  // NOTE: Full "always solvable" generation requires a stronger solver and generate+verify.
  // For this prototype we generate reasonable boards and verify at least 1 immediate break is possible.
  // You can tighten it later with deeper verification.

  function generateLevelBoard(){
    const N = state.N;
    state.board = Array.from({length:N}, () => Array.from({length:N}, () => null));
    state.tilesById = {};
    state.nextTileId = 1;

    // Determine empties: always at least 1.
    // Rule: about 15% empties, clamped.
    const total = N*N;
    const empties = clamp(Math.floor(total * (N === 3 ? 1/9 : 0.15)), 1, Math.max(1, total - 8));
    const filled = total - empties;

    // Choose number of colors: between 2 and 7, but limited by filled cells and min 2 each.
    const maxColors = Math.min(7, Math.floor(filled/2));
    const minColors = Math.min(2, maxColors);
    const colorCount = randInt(minColors, maxColors);

    // Assign counts: each >=2, sum to filled
    const counts = Array.from({length: colorCount}, () => 2);
    let remaining = filled - (2*colorCount);
    while (remaining > 0){
      counts[randInt(0, colorCount-1)] += 1;
      remaining -= 1;
    }

    // Place tiles randomly, then enforce at least one immediate break possible.
    // We'll try multiple attempts.
    const MAX_ATTEMPTS = 120;
    for (let attempt=0; attempt<MAX_ATTEMPTS; attempt++){
      clearBoardOnly(N);

      // Create list of positions
      const positions = [];
      for (let y=0; y<N; y++) for (let x=0; x<N; x++) positions.push([x,y]);
      shuffle(positions);

      // Reserve empties (first E positions)
      const emptySet = new Set();
      for (let i=0; i<empties; i++){
        const [x,y] = positions[i];
        emptySet.add(key(x,y));
      }

      // Create a flat list of colorIds according to counts
      const colorIds = [];
      for (let i=0; i<colorCount; i++){
        for (let c=0; c<counts[i]; c++) colorIds.push(i);
      }
      shuffle(colorIds);

      // Fill remaining cells
      let idx = 0;
      for (let i=empties; i<positions.length; i++){
        const [x,y] = positions[i];
        const colorId = colorIds[idx++];
        const id = state.nextTileId++;
        state.tilesById[id] = {id, colorId, x, y};
        state.board[y][x] = id;
      }

      // Verify: at least one move leads to at least one color break.
      const dirs = ["up","down","left","right"];
      let ok = false;
      for (const d of dirs){
        const sim = simulateMove(state, d);
        if (sim.brokenCount > 0){ ok = true; break; }
      }
      if (!ok) continue;
      // Reject boards that already contain an immediate break at spawn
      const immediate = computeBreaks();
      if (immediate.idsToRemove.length > 0) continue;
      // Solvability gate:
      // - If the solver can PROVE it's impossible, reject.
      // - For small boards (<=5), require the solver to actually find a full solution.
      const solv0 = analyzeSolvabilityForSnapshot(snapshotFromState(state), {
        timeBudgetMs: (N <= 3 ? 140 : (N <= 5 ? 220 : 35)),
        nodeLimit: (N <= 3 ? 80000 : (N <= 5 ? 140000 : 6000)),
      });
      if (solv0.status === "exhausted") continue;
      if (N <= 5 && solv0.status !== "solved") continue;


      // Also avoid trivial immediate win for small boards too often
      // but allow it sometimes.
      break;
    }

    function clearBoardOnly(N){
      state.board = Array.from({length:N}, () => Array.from({length:N}, () => null));
      state.tilesById = {};
      state.nextTileId = 1;
    }
  }

  // ===== Worker solver =====
  let solverWorker = null;
  let solverReqId = 1;
  const solverPending = new Map();

  function initSolverWorker(){
    if (solverWorker) return;
    try{
      solverWorker = new Worker("solver-worker.js");
      solverWorker.onmessage = (e) => {
        const { id, ok, res, err } = e.data || {};
        const p = solverPending.get(id);
        if (!p) return;
        solverPending.delete(id);
        if (ok) p.resolve(res);
        else p.reject(new Error(err || "Worker error"));
      };
      solverWorker.onerror = (e) => {
        // fallback: se crasha il worker, lo disattiviamo
        try{ solverWorker.terminate(); }catch(_){}
        solverWorker = null;
        // risolviamo pending come "unknown" per non bloccare tutto
        for (const [id, p] of solverPending.entries()){
          p.resolve({status:"unknown", firstDir:null, expanded:0, visited:0});
          solverPending.delete(id);
        }
      };
    }catch(_){
      solverWorker = null;
    }
  }

  function workerAnalyzeSolvability(snap, movesBudget, opts){
    if (!solverWorker) return Promise.resolve(null);
    const id = solverReqId++;
    return new Promise((resolve, reject) => {
      solverPending.set(id, {resolve, reject});
      solverWorker.postMessage({ id, snap, movesBudget, opts });
    });
    
  }

  async function generateLevelBoardGated(){
    const movesBudget = Math.max(0, (state.moves|0));

    const uniq = (arr) => {
      const out = [];
      const seen = new Set();
      for (const x of arr){
        if (seen.has(x)) continue;
        seen.add(x);
        out.push(x);
      }
      return out;
    };

    // Preferenza “normale” (livello), ma poi la correggiamo in base alle mosse reali
    const preferByLevel = pickGridSizeForLevel(state.level);

    // Candidate sizes “in base alle mosse”: se hai poche mosse, scala giù anche se sei al livello 100
    let byMoves;
    if (RELAX_MODE){
      byMoves = (movesBudget <= 7) ? [3,5] : [5,3];
    } else {
      if (movesBudget <= 6)       byMoves = [3,5];
      else if (movesBudget <= 10) byMoves = [5,3,7];
      else if (movesBudget <= 16) byMoves = [7,5,3,10];
      else                        byMoves = [10,7,5,3];
    }

    // Ordine finale: prefer livello in testa, poi la scala per mosse
    const candidateSizes = uniq([preferByLevel, ...byMoves]);

    // Budget solver per size (generazione può “spendere” più del hint veloce)
    const solverOptsForN = (N) => {
      if (N <= 3) return { timeBudgetMs: 180, nodeLimit: 220000 };
      if (N <= 5) return { timeBudgetMs: 260, nodeLimit: 320000 };
      if (N <= 7) return { timeBudgetMs: 360, nodeLimit: 420000 };
      return          { timeBudgetMs: 520, nodeLimit: 520000 }; // 10x10: più budget
    };

    // retries per size
    const triesForN = (N) => {
      if (N <= 3) return 70;
      if (N <= 5) return 60;
      if (N <= 7) return 40;
      return 26; // 10x10: meno tentativi, ma ogni tentativo è più “caro”
    };

    // Gate: accettiamo SOLO se troviamo una soluzione ENTRO movesBudget
    for (const N of candidateSizes){
      const TRIES = triesForN(N);
      for (let t = 0; t < TRIES; t++){
        state.N = N;

        // Genera board
        generateLevelBoard();
        // lascia respirare l'UI (soprattutto su TWA)
        await new Promise(r => setTimeout(r, 0));

        // Verifica solvibilità entro mosse attuali
        const snap = snapshotFromState(state);
        let solv = null;

        // prova worker
        if (solverWorker){
          try{
            solv = await workerAnalyzeSolvability(snap, movesBudget, solverOptsForN(N));
          }catch(_){
            solv = null;
          }
        }

        // fallback sync (browser che non supporta / worker morto)
        if (!solv){
          solv = analyzeSolvabilityForSnapshotWithMoves(snap, movesBudget, solverOptsForN(N));
        }

        if (solv.status === "solved"){
          return true;
        }
        // se unknown/exhausted => rigenera
      }
    }

    // Fallback di sicurezza: forza 3x3 e rigenera finché risolvibile
    state.N = 3;
    for (let t = 0; t < 200; t++){
      generateLevelBoard();
      // lascia respirare l'UI (soprattutto su TWA)
      await new Promise(r => setTimeout(r, 0));

      const snap = snapshotFromState(state);
      const solv = analyzeSolvabilityForSnapshotWithMoves(snap, movesBudget, { timeBudgetMs: 220, nodeLimit: 380000 });
      if (solv.status === "solved") return true;
    }

    // Se anche qui fallisse (ultra improbabile), almeno non crashiamo
    generateLevelBoard();
    return true;
  }

  // ==========
  // Rendering
  // ==========
  function renderAll(forceGrid){
    updateHUD();
    if (forceGrid) renderGridBase();
    renderTiles();
    updateButtons();
  }

  function updateHUD(){
    if (!state) return;
    elLevel.textContent = String(state.level);
    elSize.textContent  = `${state.N}×${state.N}`;
    elMoves.textContent = String(state.moves);
    elScore.textContent = String(state.score);
    // Highest score (persisted)
    if (elBestScore) {
      const best = parseInt(localStorage.getItem("psb_best_score") || "0", 10) || 0;
      elBestScore.textContent = String(best);
    }

  }

  function renderGridBase(){
    const N = state.N;
    elGrid.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
    elGrid.style.gridTemplateRows = `repeat(${N}, 1fr)`;
    elGrid.innerHTML = "";
    for (let i=0; i<N*N; i++){
      const div = document.createElement("div");
      div.className = "cell";
      elGrid.appendChild(div);
    }
  }

  function renderTiles(){
    const N = state.N;

    // compute cell size and positions based on current board size
    const rect = elBoard.getBoundingClientRect();
    const innerPad = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--board-pad')) || 14;
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 10;
    const innerW = rect.width - innerPad*2;
    const innerH = rect.height - innerPad*2;
    const cellW = (innerW - gap*(N-1)) / N;
    const cellH = (innerH - gap*(N-1)) / N;
    LAST_CELL_W = cellW;
    LAST_CELL_H = cellH;

    // Ensure DOM nodes exist for tiles
    const existing = new Map();
    Array.from(elTiles.children).forEach(node => {
      if (node.dataset && node.dataset.id) existing.set(Number(node.dataset.id), node);
    });

    // Create/update
    for (const idStr of Object.keys(state.tilesById)){
      const id = Number(idStr);
      const t = state.tilesById[id];
      let node = existing.get(id);
      if (!node){
        node = document.createElement("div");
        node.className = "tile";
        node.dataset.id = String(id);

        const glyph = document.createElement("div");
        glyph.className = "glyph";
        glyph.innerHTML = GLYPHS[t.colorId] || GLYPHS[0];
        node.appendChild(glyph);

        elTiles.appendChild(node);
      }

      const xpx = t.x * (cellW + gap);
      const ypx = t.y * (cellH + gap);

      node.style.setProperty("--x", `${xpx}px`);
      node.style.setProperty("--y", `${ypx}px`);
      node.style.setProperty("--w", `${cellW}px`);
      node.style.setProperty("--h", `${cellH}px`);
      node.style.background = COLORS[t.colorId % COLORS.length];

      // ensure glyph stays correct if palette reused
      const glyph = node.querySelector('.glyph');
      if (glyph && glyph.dataset.cid !== String(t.colorId)){
        glyph.dataset.cid = String(t.colorId);
        glyph.innerHTML = GLYPHS[t.colorId] || GLYPHS[0];
      }

      existing.delete(id);
    }

    // Remove nodes not in state
    for (const [id, node] of existing){
      node.remove();
    }
  }


  function openGameOver(reason){
    if (!gameOverOverlay) return;

    const txt = document.getElementById("gameOverText");
    if (txt) txt.textContent = reason ? String(reason) : "Mosse finite.";

    gameOverOverlay.classList.remove("hidden");
    gameOverOverlay.classList.add("show");
    gameOverOverlay.setAttribute("aria-hidden","false");

    const canUndo = !!(state.undoAvailable && state.undoSnapshot);
    if (btnGameOverUndo){
      btnGameOverUndo.disabled = !canUndo;
      btnGameOverUndo.classList.toggle("undo-disabled", !canUndo);
    }
  }

  function closeGameOver(){
    if (!gameOverOverlay) return;
    gameOverOverlay.classList.add("hidden");
    gameOverOverlay.classList.remove("show");
    gameOverOverlay.setAttribute("aria-hidden","true");
  }

  function updateButtons(){
    btnUndo.disabled = isAnimating || !state.undoAvailable || !state.undoSnapshot;
    btnHint.disabled = isAnimating || state.impossible || state.hintCharges <= 0;
    updateHintBadge();
  }


  function onRewardedAdCompleted(){
    state.hintCharges += 2;
    updateHintBadge();
    saveNow();
  }

  // ==========
  // Input
  // ==========
  function attachInput(){
    let startX=0, startY=0;
    let active = false;
    // ===== SAFETY: evita swipe fantasma su TWA (active bloccato) =====
    const cancelGesture = () => { active = false; };

    // Se parte un touch e poi viene "cancellato" dal sistema (molto comune su mobile/TWA)
    elBoard.addEventListener("touchcancel", cancelGesture, { passive: true });

    // Se l'app perde focus / va in background / cambia visibilità
    window.addEventListener("blur", cancelGesture, { passive: true });
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) cancelGesture();
    }, { passive: true });

    // Qualsiasi tap/click FUORI dalla board deve annullare una gesture rimasta appesa
    document.addEventListener("mousedown", (e) => {
      if (!elBoard.contains(e.target)) cancelGesture();
    }, true);

    document.addEventListener("touchstart", (e) => {
      const t = e.target;
      if (t && !elBoard.contains(t)) cancelGesture();
    }, { capture: true, passive: true });


    const THRESH_BASE = 18;
    const THRESH = () => Math.max(10, THRESH_BASE - Math.floor((GAME_SPEED - 1) * 2));


    const onStart = (clientX, clientY) => {
      if (!INSTANT_MODE && isAnimating) return;
      active = true;
      startX = clientX;
      startY = clientY;
    };

    const onEnd = (clientX, clientY) => {
      if (!active || (!INSTANT_MODE && isAnimating)) return;
      active = false;
      const dx = clientX - startX;
      const dy = clientY - startY;
      if (Math.hypot(dx,dy) < THRESH()) return;
      const dir = Math.abs(dx) > Math.abs(dy)
        ? (dx>0 ? "right" : "left")
        : (dy>0 ? "down" : "up");
      doMove(dir);
    };

    // Touch
    elBoard.addEventListener("touchstart", (e) => {
      if (!e.touches || !e.touches[0]) return;
      e.preventDefault();
      onStart(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive:false});

    elBoard.addEventListener("touchend", (e) => {
      e.preventDefault();
      const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
      if (!t) return;
      onEnd(t.clientX, t.clientY);
    }, {passive:false});

    // Mouse
    elBoard.addEventListener("mousedown", (e) => {
      e.preventDefault();
      onStart(e.clientX, e.clientY);
    });
    window.addEventListener("mouseup", (e) => {
      if (!active) return;
      onEnd(e.clientX, e.clientY);
    });

    // Keyboard
    window.addEventListener("keydown", (e) => {
      if (!INSTANT_MODE && isAnimating) return;
      const k = e.key;
      if (k === "ArrowUp") doMove("up");
      else if (k === "ArrowDown") doMove("down");
      else if (k === "ArrowLeft") doMove("left");
      else if (k === "ArrowRight") doMove("right");
    });
  }


  function attachButtons(){
    

    btnGameOverUndo?.addEventListener("click", () => {
      if (btnGameOverUndo.disabled) return;
      closeGameOver();
      btnUndo.click(); // riusa la logica Undo normale
    });

    btnGameOverClose?.addEventListener("click", () => {
      closeGameOver();

      // ricomincia partita
      state = newGameState();
      generateLevelBoard();
      state.levelPlan.bestFirstDir =
        computeHintDirectionForCurrentState({ maxDepth: 6, timeBudgetMs: 25 });

      saveNow();
      renderAll(true);
    });

    // =========================
    // UNDO BUTTON (NORMALE)
    // =========================

    btnUndo.addEventListener("click", () => {

      if (isAnimating) return;

      // chiudi eventuale overlay hint prima di modificare lo stato
      hideHint();

      // undo disponibile?
      if (!state.undoAvailable || !state.undoSnapshot) return;

      // === FIX: Undo non deve MAI "rimborsare" hint usati ===
      const prevHintCharges  = Number.isFinite(state.hintCharges) ? state.hintCharges : 0;
      const prevHintCooldown = Number.isFinite(state.hintCooldown) ? state.hintCooldown : 0;

      // ripristina snapshot e brucia l'undo
      restoreSnapshot(state.undoSnapshot);
      state.undoAvailable = false;
      state.undoSnapshot = null;

      // applica vincolo: dopo undo gli hint non possono aumentare
      const afterCharges  = Number.isFinite(state.hintCharges) ? state.hintCharges : 0;
      const afterCooldown = Number.isFinite(state.hintCooldown) ? state.hintCooldown : 0;

      state.hintCharges  = Math.min(afterCharges, prevHintCharges);
      state.hintCooldown = Math.max(afterCooldown, prevHintCooldown);

      saveNow();
      renderAll(true);
      stalloShown = false;
      toastMsg("Undo usato");
      stalloShown = false;
      stopPulseUndoButton();
    });

    
    btnHint.addEventListener("click", () => {
      if (isAnimating) return;
      if (state.impossible) return;

      if (state.hintCharges <= 0) {
        openReward();
        return;
      }

      showHint();
      updateButtons();
    });

    


        btnNew.addEventListener("click", async () => {
          if (isAnimating) return;

          hideHint();

          if (!(await uiConfirm(t("confirm.new_game") || "Start a new game?"))) return;

          try {
            // reset totale e coerente
            state = newGameState();

            // IMPORTANTISSIMO: usa la stessa logica dei livelli (gated + render + save)
            void startLevel(1);

            // opzionale: se vuoi anche il toast "Nuova partita"
            // toastMsg(t("toast.new_game"));
          } catch (e) {
            console.error("NEW GAME ERROR:", e);
            await uiAlert((t("error.new_game") || "Errore durante Nuova partita") + ": " + (e?.message || e));

            // fallback: almeno forziamo un render completo
            try { renderAll(true); } catch (_) {}
          }
        });

        btnCloseHint.addEventListener("click", () => {
          hideHint();
        });

        hintOverlay.addEventListener("click", (e) => {
          if (e.target === hintOverlay) hideHint();
        });

        window.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && hintOverlay.classList.contains("show")) hideHint();
        });


        // Reward overlay bindings (ensure DOM exists)
        const rewardOverlay = document.getElementById("rewardOverlay");
        const btnReward2Hints = document.getElementById("btnReward2Hints");
        const btnRewardWatch = document.getElementById("btnRewardWatch");
        const btnRewardCancel = document.getElementById("btnRewardCancel");
        const rewardOverlayStatus = document.getElementById("rewardOverlayStatus");

        function openReward(){
          if (!rewardOverlay) return;
          rewardOverlay.classList.remove("hidden");
          rewardOverlay.setAttribute("aria-hidden","false");
          if (rewardOverlayStatus) rewardOverlayStatus.textContent = "";
        }
        function closeReward(){
          if (!rewardOverlay) return;
          rewardOverlay.classList.add("hidden");
          rewardOverlay.setAttribute("aria-hidden","true");
        }

        if (btnReward2Hints) btnReward2Hints.addEventListener("click", openReward);
        if (btnRewardCancel) btnRewardCancel.addEventListener("click", closeReward);

        if (btnRewardWatch) btnRewardWatch.addEventListener("click", async () => {
          try{
            btnRewardWatch.disabled = true;
            if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Caricamento…";
            const r = await Ads.showRewardedFor2Hints();
            if (r && r.ok && r.rewarded){
              if (typeof onRewardedAdCompleted === "function") onRewardedAdCompleted();
              if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Ok! +2 hint aggiunti.";
              closeReward();
            } else {
              const reason = r?.reason || "no_reward";
              if (rewardOverlayStatus) rewardOverlayStatus.textContent =
                (reason === "web_no_ads") ? "Disponibile solo nell’app Android." :
                (reason === "cooldown") ? "Riprova tra poco." :
                "Pubblicità non disponibile ora.";
            }
          } catch(e){
            if (rewardOverlayStatus) rewardOverlayStatus.textContent = "Errore: " + (e?.message || e);
          } finally {
            btnRewardWatch.disabled = false;
          }
        });

              

  }



  function openPrivacy(){
    const ov = document.getElementById("privacyOverlay");
    if (!ov) return;
    ov.classList.remove("hidden");
    ov.classList.add("show");
  }

  function closePrivacy(){
    const ov = document.getElementById("privacyOverlay");
    if (!ov) return;
    ov.classList.add("hidden");
    ov.classList.remove("show");
  }

  document.addEventListener("click", (e) => {
    const t = e.target;

    // click sulla X
    if (t && (t.id === "btnClosePrivacy" || t.closest?.("#btnClosePrivacy"))) {
      e.preventDefault();
      e.stopPropagation();
      closePrivacy();
      return;
    }

    // click fuori dal modal (sullo sfondo overlay)
    const ov = document.getElementById("privacyOverlay");
    if (ov && !ov.classList.contains("hidden") && t === ov) {
      closePrivacy();
    }
  });
  // listeners
  document.getElementById("btnClosePrivacy")?.addEventListener("click", closePrivacy);

  // chiudi cliccando fuori dalla card
  document.getElementById("privacyOverlay")?.addEventListener("click", (e) => {
    if (e.target && e.target.id === "privacyOverlay") closePrivacy();
  });

  // ESC per chiudere
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closePrivacy();
  });


  const btnAuto = document.getElementById("btnAuto");

  if (btnAuto){
    btnAuto.addEventListener("click", async () => {
      if (AUTO_MODE){
        exitAutoTutorial();   // ripristina partita vera + stop
        return;
      }

      // START
      AUTO_MODE = true;
      applyFxSpeed();
      autoStop = false;
      btnAuto.classList.add("active");
      toastMsg("AUTO: ON");
      enterAutoTutorial(); // tutorial sempre da zero

      // facoltativo: crea una partita “pulita” non salvata
      // se hai una funzione newGame / reset / startGame, chiamala qui:
      // startNewGame?.();

      if (!autoLoopRunning){
        autoLoopRunning = true;
        runAutoLoop().finally(() => { autoLoopRunning = false; });
      }
    });
  }

  async function runAutoLoop(){
    try{
      while (AUTO_MODE && !autoStop){
        await waitNotBusy();

        const pick = await pickBestDirAuto();

        if (!AUTO_MODE || autoStop) break;

        if (pick?.dir){
          // esegui la mossa (usa la tua funzione reale: doMove / applyMove / swipeMove etc.)
          // Cerca nel file la funzione che viene chiamata quando fai swipe.
          if (typeof doMove === "function"){
            
              try {
              await doMove(pick.dir);
            } catch (e) {
              console.error("AUTO stopped:", e);
              bigToast("AUTO: errore animazione", 1200);
              AUTO_MODE = false;
              autoStop = true;
              break;
            }

          } else if (typeof performMove === "function"){
            await performMove(pick.dir);
          } else {
            // fallback: se non trovi, almeno fermati
            bigToast("AUTO: manca doMove()", 1200);
            AUTO_MODE = false;
            break;
          }

          await sleep(AUTO_STEP_DELAY_MS);
          continue;
        }

        // nessuna mossa trovata
        // nessuna mossa trovata → in AUTO rigeneriamo SEMPRE un livello pulito
        bigToast("AUTO: regen level", 700);
        showStalloMessage();
        pulseUndoButton();

        regenCleanLevel();
        await sleep(120);
        continue;


        // se per qualche motivo il solver deep non esiste
        bigToast("AUTO: solver non disponibile", 1200);
        AUTO_MODE = false;
      }
    } finally {
          // se esce per qualunque motivo (solver, errore, exhausted, ecc.)
    // e non hai già ripristinato manualmente, ripristina qui
        if (autoReturnSnapshot){
          exitAutoTutorial({silent:true});
        }
    }
  }


  
  function checkLevelReward(level) {
    if (level < 10) return 0;

    // verifica se è 10 * 2^k
    if ((level % 10) !== 0) return 0;

    const q = level / 10;
    if ((q & (q - 1)) !== 0) return 0; // non è potenza di 2

    return 10;
  }


  // ==========
  // Move logic
  // ==========
  async function doMove(dir){
    const instant = INSTANT_MODE;

    // Normal mode: block input while a move is running
    if (!instant && isAnimating) return;

    // In instant mode: cancel any in-flight move pipeline immediately
    const token = ++MOVE_TOKEN;
    if (instant && isAnimating){
      isAnimating = false;
      updateButtons();
    }

    if (state.moves <= 0) {
      state.moves = 0;          // clamp
      gameOver("Mosse finite");    
      updateButtons?.();        // se esiste (altrimenti rimuovi questa riga)
      return;                   // FONDAMENTALE: stop totale
    }

    if (state.moves < 0) state.moves = 0;

    const before = snapshotState();

    // Apply movement
    const moved = applyMovement(dir);

    // Save undo snapshot SOLO se la mossa ha davvero mosso qualcosa
    if (moved && state.undoAvailable && !state.undoSnapshot){
      state.undoSnapshot = before;
    }

    // Se non si muove nulla, NON consumare mosse
    if (!moved){
      toastMsg("Nessuno spostamento");
      saveNow();
      renderAll(true);
      updateButtons();
      return;
    }

    // Consuma una mossa SOLO se c'è stato movimento
    state.moves -= 1;

    // Durate “reali” (non leggere le CSS var: potrebbero essere espressioni non parseabili)
    const MOVE_MS     = Math.max(240 / GAME_SPEED, 40);
    const PREBREAK_MS = Math.max(420 / GAME_SPEED, 70);
    const FADE_MS     = Math.max(260 / GAME_SPEED, 50);

    // Animate movement
    if (!instant){
      isAnimating = true;
      updateButtons();

      // 0) aggiorna SUBITO il DOM: così parte lo "scivolamento" (CSS transition)
      renderAll(false);
      await nextFrame();
      if (token !== MOVE_TOKEN){ isAnimating = false; updateButtons(); return; }

      // 1) attendi una durata deterministica (niente blocchi dovuti a transitionend mancati)
      await sleep(MOVE_MS);
      if (token !== MOVE_TOKEN){ isAnimating = false; updateButtons(); return; }
    } else {
      // Instant: aggiorna subito, nessuna attesa
      renderAll(false);
    }

    // 2) a movimento “finito” (o istantaneo) calcoliamo cosa si rompe
    const broken = computeBreaks();

    let brokeCount = 0;
    if (broken.breakColorIds.length > 0){
      const idsToRemove = new Set(broken.idsToRemove);
      brokeCount = idsToRemove.size;

      if (!instant){
        // 1) enfasi visibile prima della rottura
        markPreBreak(idsToRemove);
        await sleep(PREBREAK_MS);
        if (token !== MOVE_TOKEN){ isAnimating = false; updateButtons(); return; }
      }

      haptic(idsToRemove.size >= 8 ? [12, 20, 12] : HAPTIC_BREAK);

      // 2) rottura vera e propria (fade + stelle)
      playBreakAnimation(idsToRemove);
      
      // In instant mode: nessuna attesa, rimozione immediata
      if (!instant){
        await sleep(15);
        if (token !== MOVE_TOKEN){ isAnimating = false; updateButtons(); return; }
      }

      // Apply removal
      for (const id of idsToRemove){
        const t = state.tilesById[id];
        if (!t) continue;
        state.board[t.y][t.x] = null;
        delete state.tilesById[id];
      }

      // Points are global
      let gained = Math.floor(brokeCount / 2);
      if (brokeCount > 0) gained = Math.max(gained, 1);
      state.score += gained;
      state.moves += gained;

      // Check for new local best score and submit if logged in
      try {
        const prevBest = parseInt(localStorage.getItem('psb_best_score') || '0', 10) || 0;
        if (state.score > prevBest) {
          localStorage.setItem('psb_best_score', String(state.score));
          submitHighScoreIfLoggedIn(state.score);
        }
      } catch (e) { /* ignore storage errors */ }

      if (!instant){
        // Allow fade
        await sleep(FADE_MS);
        if (token !== MOVE_TOKEN){ isAnimating = false; updateButtons(); return; }
      }

      toastMsg(`Rotti ${brokeCount} • +${gained} mosse`);
    }

    // Render after changes
    renderAll(false);

    // End of move
    if (!instant){
      isAnimating = false;
      updateButtons();
    } else {
      updateButtons();
    }

    // Win/lose checks
    if (Object.keys(state.tilesById).length === 0){
      // Level complete
      try{
        showLevelLoading(`Livello ${state.level + 1}...`);
        await nextFrame();              // IMPORTANTISSIMO: fa “paint” dell’overlay prima del solver

        if (!instant) await sleep(40);  // micro-respiro, opzionale
        await startLevel(state.level + 1);
      } finally {
        hideLevelLoading();
      }
      return;

    }

    // Dead-end / moves ended
    if (state.moves <= 0){
      gameOver("Mosse finite");
      return;
    }

    // If we're in a position that the solver can PROVE is impossible (state-space exhausted),
    // disable Hint and tell the user to Undo (English message as requested).
    if (Object.keys(state.tilesById).length > 0 && state.undoSnapshot){
      const quick = anyBreakPossibleSoon(4);
      if (!quick){
        let solv = { status: "unknown" };
        try{
          if (typeof analyzeSolvabilityCurrentState === "function") {
            solv = analyzeSolvabilityCurrentState({
              timeBudgetMs: (state.N <= 5 ? 70 : 28),
              nodeLimit: (state.N <= 5 ? 18000 : 4500),
            }) || { status: "unknown" };
          }
        } catch (e){
          // se qualcosa va storto col solver, non bloccare la UI
          solv = { status: "unknown" };
        }

        if (solv.status === "exhausted") {
          showStalloMessage();
          pulseUndoButton();
        }else {
          state.impossible = false;
          state.impossibleNotified = false;
        }

        updateButtons();
      } else {
        state.impossible = false;
      }
    } else {
      state.impossible = false;
    }

    saveNow();

    if (brokeCount === 0){
      toastMsg("Nessuna rottura");
    }

    // Keep snapshot for debugging if needed
    void(before);
  }

  function applyMovement(dir){
    const N = state.N;
    let movedAny = false;

    // We'll create new board with same tiles, but moved.
    // For determinism and correctness we compress each line.

    const boardNew = Array.from({length:N}, () => Array.from({length:N}, () => null));

    const updateTile = (id, nx, ny) => {
      const t = state.tilesById[id];
      if (t.x !== nx || t.y !== ny) movedAny = true;
      t.x = nx; t.y = ny;
      boardNew[ny][nx] = id;
    };

    if (dir === "left" || dir === "right"){
      for (let y=0; y<N; y++){
        const line = [];
        for (let x=0; x<N; x++){
          const id = state.board[y][x];
          if (id != null) line.push(id);
        }
        if (dir === "right") line.reverse();

        // place starting at 0 (in direction), preserving order
        for (let i=0; i<line.length; i++){
          const id = line[i];
          const x = (dir === "left") ? i : (N-1-i);
          updateTile(id, x, y);
        }
      }
    } else {
      for (let x=0; x<N; x++){
        const line = [];
        for (let y=0; y<N; y++){
          const id = state.board[y][x];
          if (id != null) line.push(id);
        }
        if (dir === "down") line.reverse();

        for (let i=0; i<line.length; i++){
          const id = line[i];
          const y = (dir === "up") ? i : (N-1-i);
          updateTile(id, x, y);
        }
      }
    }

    state.board = boardNew;
    return movedAny;
  }

  function computeBreaks(){
    // Determine for each colorId if all its tiles are connected (4-dir). If yes, break all of them.
    const tiles = Object.values(state.tilesById);
    if (tiles.length === 0) return {breakColorIds:[], idsToRemove:[]};

    // group by color
    const byColor = new Map();
    for (const t of tiles){
      if (!byColor.has(t.colorId)) byColor.set(t.colorId, []);
      byColor.get(t.colorId).push(t);
    }

    const idsToRemove = [];
    const breakColorIds = [];

    for (const [colorId, list] of byColor.entries()){
      if (list.length < 2) continue; // rule: at least 2 by design
      // BFS from first tile
      const target = new Set(list.map(t => key(t.x,t.y)));
      const visited = new Set();
      const q = [list[0]];
      visited.add(key(list[0].x, list[0].y));

      while (q.length){
        const cur = q.shift();
        const neigh = neighbors4(cur.x, cur.y, state.N);
        for (const [nx,ny] of neigh){
          const k = key(nx,ny);
          if (visited.has(k)) continue;
          // only traverse cells that contain that color
          const id = state.board[ny][nx];
          if (id == null) continue;
          const t = state.tilesById[id];
          if (!t || t.colorId !== colorId) continue;
          visited.add(k);
          q.push(t);
        }
      }

      // Connected if visited covers all positions
      let allConnected = true;
      for (const pos of target){
        if (!visited.has(pos)) {allConnected=false; break;}
      }

      if (allConnected){
        breakColorIds.push(colorId);
        for (const t of list) idsToRemove.push(t.id);
      }
    }

    return {breakColorIds, idsToRemove};
  }

  // shallow check: can any move create a break within k plies (simple; not exhaustive)
  function anyBreakPossibleSoon(depth){
    const dirs = ["up","down","left","right"];
    const base = snapshotState();

    const dfs = (d) => {
      if (d === 0) return false;
      for (const dir of dirs){
        const sim = simulateMoveFromSnapshot(base, dir);
        if (sim.brokenCount > 0) return true;
      }
      return false;
    };
    return dfs(depth);
  }

  // ==========
  // Hint + Solver (lightweight demo)
  // ==========
  
  function openHintOverlay(){
    // mostra overlay
    hintOverlay.classList.add("show");
    hintOverlay.setAttribute("aria-hidden","false");

    // focus dentro al dialog (aiuta anche per accessibilità)
    requestAnimationFrame(() => {
      try { btnCloseHint?.focus(); } catch {}
    });
  }


  function showHint(){
    if (isAnimating) return;

    // già provato impossibile
    if (state.impossible){
      hintText.textContent = "Impossible situation. Use Undo.";
      openHintOverlay();
      return;
    }

    // apri hint anche con 0 (come già fai)
    if (!Number.isFinite(state.hintCharges)) state.hintCharges = 0;
    if (state.hintCharges <= 0){
      const cd = Number.isFinite(state.hintCooldown) ? state.hintCooldown : 0;
      hintText.textContent = cd > 0
        ? `No hints available. Earn one in ${cd} level(s).`
        : "No hints available right now. Complete levels to earn more.";
      openHintOverlay();
      return;
    }

    // 1) solver leggero (NON consuma ancora)
    const solv = analyzeSolvabilityCurrentState({
      timeBudgetMs: (state.N <= 5 ? 70 : 28),
      nodeLimit: (state.N <= 5 ? 18000 : 4500),
    });

    // 2) se PROVA che è impossibile => STALLO (no consumo)
    if (solv.status === "exhausted"){
      state.impossible = true;
      saveNow();
      updateButtons();

      showStalloMessage();
      pulseUndoButton();

      hintText.textContent = "Impossible situation. Use Undo.";
      openHintOverlay();
      return;
    }

    // 3) se risolta => dir immediata
    let dir = (solv.status === "solved") ? solv.firstDir : null;

    // 4) se unknown/non solved: NON consumare, chiedi heavy compute
    if (!dir && solv.status === "unknown"){
      openHintHeavyPrompt();
      return;
    }

    // 5) fallback euristico (ancora NON consumiamo finché non abbiamo dir)
    if (!dir) dir = state.levelPlan.bestFirstDir;
    if (!dir) dir = computeHintDirectionForCurrentState({maxDepth: 8, timeBudgetMs: 50});

    if (!dir){
      // qui NON sprechiamo: se non sappiamo, chiediamo heavy
      openHintHeavyPrompt();
      return;
    }

    // 6) ORA consumiamo (solo perché abbiamo una direzione)
    state.hintCharges -= 1;
    if (state.hintCharges === 0) state.hintCooldown = 3;
    saveNow();
    updateButtons();

    hintText.textContent = `Recommended direction: ${dirToArrow(dir)}. (Simulation: 1 move)`;
    openHintOverlay();
    requestAnimationFrame(() => requestAnimationFrame(() => renderHintDemo(dir)));
  }

  function openHintHeavyPrompt(){
    const ov = document.getElementById("hintHeavyOverlay");
    const sp = document.getElementById("hintHeavySpinner");
    const tx = document.getElementById("hintHeavyText");
    const go = document.getElementById("btnHintHeavyGo");

    tx.textContent =
      "Questo livello richiede un calcolo più pesante per trovare una mossa vincente (o provare lo stallo). Vuoi procedere?";
    sp.classList.add("hidden");
    go.disabled = false;

    ov.classList.add("show");
  }

  function closeHintHeavyPrompt(){
    const ov = document.getElementById("hintHeavyOverlay");
    ov.classList.remove("show");
  }

  async function runHeavyHint(){
    const sp = document.getElementById("hintHeavySpinner");
    const tx = document.getElementById("hintHeavyText");
    const go = document.getElementById("btnHintHeavyGo");

    go.disabled = true;
    sp.classList.remove("hidden");
    tx.textContent = "Calcolo in corso…";

    // lascia respirare la UI prima del calcolo
    await nextFrame();
    await nextFrame();

    const deep = analyzeSolvabilityCurrentState({
      timeBudgetMs: 900,     // puoi alzare anche a 1500
      nodeLimit: 220000      // puoi alzare se vuoi
    });

    sp.classList.add("hidden");

    if (deep.status === "exhausted"){
      state.impossible = true;
      saveNow();
      updateButtons();

      closeHintHeavyPrompt();
      showStalloMessage();
      pulseUndoButton();

      // NON consumiamo hint
      hintText.textContent = "Impossible situation. Use Undo.";
      openHintOverlay();
      return;
    }

    let dir = (deep.status === "solved") ? deep.firstDir : null;
    if (!dir){
      // ancora non trovato => non consumare
      tx.textContent = "Ancora nessuna mossa trovata con questo budget. Riprova o usa Undo.";
      go.disabled = false;
      return;
    }

    // trovato => consumiamo SOLO ora
    state.hintCharges -= 1;
    if (state.hintCharges === 0) state.hintCooldown = 3;
    saveNow();
    updateButtons();

    closeHintHeavyPrompt();
    hintText.textContent = `Recommended direction: ${dirToArrow(dir)}. (Simulation: 1 move)`;
    openHintOverlay();
    requestAnimationFrame(() => requestAnimationFrame(() => renderHintDemo(dir)));
  }


  function hideHint(){
    if (window.__hintDemoStop) { window.__hintDemoStop();
    window.__hintDemoStop = null; }

    // Evita warning: non mettere aria-hidden su un elemento che contiene ancora il focus
    try {
      if (hintOverlay && hintOverlay.contains(document.activeElement)) {
        document.getElementById("btnHint")?.focus();
      }
    } catch {}

    hintOverlay.classList.remove("show");
    hintOverlay.setAttribute("aria-hidden","true");
    hintCanvasWrap.innerHTML = "";
  }

  function computeHintDirectionForCurrentState({maxDepth, timeBudgetMs}){
    // Very small DFS with time budget.
    const start = performance.now();
    const dirs = ["up","down","left","right"];

    const rootSnap = snapshotState();

    // Evaluate a move by: brokenCount immediate, then prefer more empties + fewer colors left.
    function scoreSnap(snap){
      const tileCount = Object.keys(snap.tilesById).length;
      const total = snap.N * snap.N;
      const empties = total - tileCount;
      const colorsLeft = new Set(Object.values(snap.tilesById).map(t=>t.colorId)).size;
      return empties * 1.4 - colorsLeft * 0.9;
    }

    // Try immediate moves first
    let bestDir = null;
    let bestScore = -Infinity;

    for (const dir of dirs){
      const sim = simulateMoveFromSnapshot(rootSnap, dir);
      if (sim.moved === false && sim.brokenCount === 0) {
        // still allowed, but weak
      }
      const immediate = sim.brokenCount;
      const baseScore = immediate * 8 + scoreSnap(sim.snapshot);
      if (baseScore > bestScore){
        bestScore = baseScore;
        bestDir = dir;
      }
    }

    // Depth search: only if time allows.
    // We search for a sequence that yields breaks and doesn't dead-end too fast.
    let bestSeqDir = bestDir;
    let bestSeqScore = bestScore;

    const dfs = (snap, depth, accScore, firstDir) => {
      if (performance.now() - start > timeBudgetMs) return;
      if (depth === 0) {
        if (accScore > bestSeqScore){
          bestSeqScore = accScore;
          bestSeqDir = firstDir;
        }
        return;
      }
      // Early exit if already won
      if (Object.keys(snap.tilesById).length === 0){
        if (accScore + 1000 > bestSeqScore){
          bestSeqScore = accScore + 1000;
          bestSeqDir = firstDir;
        }
        return;
      }
      for (const dir of dirs){
        const sim = simulateMoveFromSnapshot(snap, dir);
        const sc = sim.brokenCount * 9 + scoreSnap(sim.snapshot);
        dfs(sim.snapshot, depth-1, accScore + sc, firstDir);
      }
    };

    for (const dir of dirs){
      if (performance.now() - start > timeBudgetMs) break;
      const sim = simulateMoveFromSnapshot(rootSnap, dir);
      const sc = sim.brokenCount * 9 + scoreSnap(sim.snapshot);
      dfs(sim.snapshot, maxDepth-1, sc, dir);
    }

    // If best is extremely weak and no break visible soon, can return null
    // We'll return best anyway.
    return bestSeqDir;
  }


  function renderHintDemo(dir){
  // stop previous loops/timeouts (important if you open hint multiple times)
  if (window.__hintDemoStop) { window.__hintDemoStop(); window.__hintDemoStop = null; }

  hintCanvasWrap.innerHTML = "";

  const N = state.N;
  const baseSnap = snapshotState();

  // timing (slow enough to be readable)
  const MOVE_MS = 520;
  const PRE_MS  = 220;
  const FADE_MS = 260;
  const LOOP_MS = MOVE_MS + PRE_MS + FADE_MS + 650;

  const PAD = 6;
  const GAP = 6;

  const wrap = document.createElement("div");
  wrap.style.width = "min(72vw, 260px)";
  wrap.style.aspectRatio = "1 / 1";
  wrap.style.position = "relative";
  wrap.style.margin = "10px auto 0";
  wrap.style.borderRadius = "16px";
  hintCanvasWrap.appendChild(wrap);

  const bg = document.createElement("div");
  bg.style.position = "absolute";
  bg.style.inset = "0";
  bg.style.display = "grid";
  bg.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
  bg.style.gridTemplateRows = `repeat(${N}, 1fr)`;
  bg.style.gap = `${GAP}px`;
  bg.style.padding = `${PAD}px`;
  bg.style.background = "rgba(255,255,255,.06)";
  bg.style.border = "1px solid rgba(255,255,255,.12)";
  bg.style.borderRadius = "16px";
  wrap.appendChild(bg);

  for (let i=0;i<N*N;i++){
    const cell = document.createElement("div");
    cell.style.borderRadius = "12px";
    cell.style.background = "rgba(255,255,255,.05)";
    cell.style.border = "1px solid rgba(255,255,255,.06)";
    bg.appendChild(cell);
  }

  const tilesLayer = document.createElement("div");
  tilesLayer.style.position = "absolute";
  tilesLayer.style.inset = "0";
  wrap.appendChild(tilesLayer);

  const tileNodes = {};
  for (const t of Object.values(baseSnap.tilesById)){
    const node = document.createElement("div");
    node.style.position = "absolute";
    node.style.borderRadius = "12px";
    node.style.boxShadow = "0 10px 22px rgba(0,0,0,.28)";
    node.style.background = COLORS[t.colorId] || "#888";
    node.style.willChange = "transform, opacity, filter";
    node.style.opacity = "1";
    tilesLayer.appendChild(node);
    tileNodes[t.id] = node;
  }

  function measure(){
    const rect = wrap.getBoundingClientRect();
    const inner = rect.width - PAD*2 - GAP*(N-1);
    const cell = inner / N;
    return {rect, cell};
  }

  function place(snap){
    const {rect, cell} = measure();
    if (rect.width < 10) return; // not ready yet

    for (const idStr of Object.keys(baseSnap.tilesById)){
      const id = Number(idStr);
      const node = tileNodes[id];
      if (!node) continue;

      const t = snap.tilesById[idStr] || snap.tilesById[id]; // tolerate number/string keys
      if (!t){
        node.style.opacity = "0";
        continue;
      }

      const x = PAD + (cell + GAP) * t.x;
      const y = PAD + (cell + GAP) * t.y;

      node.style.width = `${cell}px`;
      node.style.height = `${cell}px`;

      const tr = `translate(${x}px, ${y}px)`;
      node.dataset.tr = tr;
      node.style.transform = tr;
    }
  }

  function setAnim(on){
    const tr = on
      ? `transform ${MOVE_MS}ms cubic-bezier(.2,.8,.2,1), opacity ${FADE_MS}ms ease, filter ${FADE_MS}ms ease`
      : "none";
    for (const n of Object.values(tileNodes)){
      n.style.transition = tr;
    }
  }

  function resetVisual(){
    for (const n of Object.values(tileNodes)){
      n.style.opacity = "1";
      n.style.filter = "";
      n.style.zIndex = "";
      if (n.dataset.tr) n.style.transform = n.dataset.tr;
    }
  }

  function preBreak(ids){
    for (const id of ids){
      const n = tileNodes[id];
      if (!n) continue;
      n.style.zIndex = "5";
      n.style.filter = "brightness(1.18)";
      const baseTr = n.dataset.tr || n.style.transform;
      n.style.transform = baseTr + " scale(1.07)";
    }
  }

  function fadeOut(ids){
    for (const id of ids){
      const n = tileNodes[id];
      if (!n) continue;
      n.style.opacity = "0";
    }
  }

  const timeouts = [];
  const later = (fn, ms) => {
    const id = setTimeout(fn, ms);
    timeouts.push(id);
    return id;
  };
  let intervalId = null;

  window.__hintDemoStop = () => {
    timeouts.forEach(clearTimeout);
    if (intervalId) clearInterval(intervalId);
    intervalId = null;
  };

  function runOnce(){
    if (!dir){
      setAnim(false);
      place(baseSnap);
      resetVisual();
      return;
    }

    const sim = simulateMovePreviewFromSnapshot(cloneHintSnapshot(baseSnap), dir);
    const movedSnap = sim.snapshot;
    const removed = sim.removedIds;

    setAnim(false);
    place(baseSnap);
    resetVisual();
    // force reflow
    void tilesLayer.offsetWidth;

    requestAnimationFrame(() => {
      setAnim(true);
      place(movedSnap);                // ✅ scorrimento di TUTTI i blocchi

      later(() => preBreak(removed), Math.max(0, MOVE_MS - 90));        // pre-break quasi a fine corsa
      later(() => fadeOut(removed), MOVE_MS + PRE_MS);                  // poi scomparsa
      later(() => {
        setAnim(false);
        resetVisual();
        place(baseSnap);                                                   // reset per loop
      }, MOVE_MS + PRE_MS + FADE_MS + 450);
    });
  }

  // Wait until modal has real size (prevents top-left collapse)
  function waitForSize(tries=0){
    const r = wrap.getBoundingClientRect();
    if (r.width > 10 || tries > 12){
      setAnim(false);
      place(baseSnap);
      resetVisual();

      runOnce();
      if (dir) intervalId = setInterval(runOnce, LOOP_MS);
      return;
    }
    requestAnimationFrame(() => waitForSize(tries+1));
  }

  waitForSize();
}

function markPreBreak(idsToRemove){
  const arr = Array.from(idsToRemove).map(Number);
  const total = arr.length;
  if (!total) return;

  const low = document.documentElement.classList.contains("lowgfx");

  // Se rompe tanti tile insieme: niente prebreak (troppo spam)
  if (total > 5) return;

  // In lowgfx usiamo una versione "lite" (solo transform)
  const cls = low ? "prebreakLite" : "prebreak";


  const idSet = new Set(arr);
  const nodes = Array.from(elTiles.children);
  for (const n of nodes){
    const id = Number(n.dataset.id);
    if (idSet.has(id)) n.classList.add(cls);

  }
}








  // ==========
  // Break animation (FAST)
  // ==========
  function playBreakAnimation(idsToRemove){
    const nodes = Array.from(elTiles.children);
    const idArr = Array.from(idsToRemove).map(Number);
    const idSet = new Set(idArr);
    const total = idSet.size;
    if (!total) return;
    // === MASS BREAK: se rompo tanti tile insieme, tolgo effetti pesanti per non laggare ===
    const mass = total > 5;
    if (mass){
      const root = document.documentElement;
      root.classList.add("massbreak");
      clearTimeout(window.__massbreakTO);
      window.__massbreakTO = setTimeout(() => root.classList.remove("massbreak"), 260);
    }


    // === Particle budget: evita esplosioni quando rompi tanti tile ===
    const low = document.documentElement.classList.contains("lowgfx");

    // budget totale per "evento break" (NON per tile)
    const TOTAL_BUDGET = low ? 36 : 72;

    // quante particelle per tile in base al numero di tile rotti
    const perTile = Math.max(0, Math.floor(TOTAL_BUDGET / total));
    const particles = (total > 12)
      ? 0
      : Math.max(0, Math.min(BREAK_PARTICLES, perTile));


    const frag = document.createDocumentFragment();

    for (const n of nodes){
      const id = Number(n.dataset.id);
      if (!idSet.has(id)) continue;

      // NIENTE getBoundingClientRect(): usiamo le CSS vars che già setti in render
      const x = parseFloat(n.style.getPropertyValue("--x")) || 0;
      const y = parseFloat(n.style.getPropertyValue("--y")) || 0;
      const w = parseFloat(n.style.getPropertyValue("--w")) || LAST_CELL_W || 0;
      const h = parseFloat(n.style.getPropertyValue("--h")) || LAST_CELL_H || 0;

      const cx = x + w/2;
      const cy = y + h/2;

      // scrittura (no layout-read prima)
      n.classList.add("fadeout");

      // particelle: se particles == 0, resta solo fadeout (super fluido)
      if (particles <= 0) continue;

      const starLayer = document.createElement("div");
      starLayer.className = "stars play";
      starLayer.style.left = `${cx}px`;
      starLayer.style.top  = `${cy}px`;

      for (let i = 0; i < particles; i++){
        const s = document.createElement("div");
        s.className = "star";
        s.style.left = "0px";
        s.style.top  = "0px";

        const a = Math.random() * Math.PI * 2;
        const r = 18 + Math.random() * 42;
        const up = -10 - Math.random() * 18;

        const dx = Math.cos(a) * r;
        const dy = Math.sin(a) * r + up;

        s.style.setProperty("--dx", `${dx}px`);
        s.style.setProperty("--dy", `${dy}px`);
        s.style.setProperty("--rot", `${randFloat(-180, 180)}deg`);
        s.style.setProperty("--sc", `${randFloat(0.65, 1.25)}`);
        s.style.animationDelay = `${Math.random() * 60}ms`;

        // s.innerHTML = starSVG();  // <-- NO: troppo pesante su mobile

        starLayer.appendChild(s);
      }

      frag.appendChild(starLayer);
    }

    if (frag.childNodes.length) elBoard.appendChild(frag);

    // cleanup unico (evita N timeout per tile)
    setTimeout(() => {
      elBoard.querySelectorAll(".stars.play").forEach(x => x.remove());
    }, 420);

    setTimeout(() => {
      for (const n of nodes){
        const id = Number(n.dataset.id);
        if (!idSet.has(id)) continue;
        n.classList.remove("fadeout","prebreak");
      }
    }, 260);

  }


  // ==========
  // Save / Load
  // ==========
  function snapshotState(){
    // Deep-ish clone minimal fields (avoid DOM)
    const snap = {
      level: state.level,
      sizeIndex: state.sizeIndex,
      N: state.N,
      score: state.score,
      moves: state.moves,
      undoAvailable: state.undoAvailable,
      hintCharges: state.hintCharges,
      hintCooldown: state.hintCooldown,
      impossible: state.impossible,
      rngSeed: state.rngSeed,
      nextTileId: state.nextTileId,
      board: state.board.map(row => row.slice()),
      tilesById: JSON.parse(JSON.stringify(state.tilesById)),
      levelPlan: JSON.parse(JSON.stringify(state.levelPlan)),
      // undoSnapshot not included to avoid recursion
      undoSnapshot: null,
    };
    return snap;
  }

  function restoreSnapshot(snap){
    state.level = snap.level;
    state.sizeIndex = snap.sizeIndex;
    state.N = snap.N;
    state.score = snap.score;
    state.moves = snap.moves;
    state.undoAvailable = snap.undoAvailable;
    state.hintCharges = snap.hintCharges;
    state.hintCooldown = snap.hintCooldown;
    state.impossible = (snap.impossible ?? false);
    state.rngSeed = snap.rngSeed;
    state.nextTileId = snap.nextTileId;
    state.board = snap.board.map(r=>r.slice());
    state.tilesById = JSON.parse(JSON.stringify(snap.tilesById));
    state.levelPlan = JSON.parse(JSON.stringify(snap.levelPlan));
  }

  function saveNow(){
    if (AUTO_MODE) return; // in tutorial mode NON si salva nulla

    const payload = snapshotState();
    // include undo snapshot separately
    payload.undoSnapshot = state.undoSnapshot;
    try {
      localStorage.setItem(userStorageKey(STORAGE_KEY), JSON.stringify(payload));
    } catch {}
  }

    function loadSave(){
    const scopedKey = userStorageKey(STORAGE_KEY);

    // Prima prova a leggere lo scoped save (per-account)
    let raw = null;
    try { raw = localStorage.getItem(scopedKey); } catch {}

    // MIGRAZIONE: se esiste un vecchio salvataggio globale (guest legacy), spostalo SOLO per guest
    const logged = !!getAccessToken();
    let legacy = null;
    try { legacy = localStorage.getItem(STORAGE_KEY); } catch {}

    if (!raw && legacy && !logged){
      try { localStorage.setItem(scopedKey, legacy); } catch {}
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      raw = legacy;
    }

    if (!raw) return null;

    try{
      const s = JSON.parse(raw);
      // basic validation
      if (!s || typeof s.N !== "number" || !Array.isArray(s.board) || !s.tilesById) return null;
      const st = newGameState();
      // merge
      Object.assign(st, s);
      // reapply nested structures safely
      st.board = s.board.map(r=>r.slice());
      st.tilesById = s.tilesById;
      st.levelPlan = s.levelPlan || {bestFirstDir:null};
      st.undoSnapshot = s.undoSnapshot || null;
      st.impossible = !!s.impossible;
      return st;
    } catch {
      return null;
    }
  }


  // ==========
  // Game Over
  // ==========
  function gameOver(reason){
    state.moves = 0;            // clamp definitivo
    openGameOver(reason);       // se vuoi mostrare la reason nell’overlay
    try { submitHighScoreIfLoggedIn(state.score); } catch (e) {}
    saveNow?.();
    renderAll?.(true);
    updateButtons?.();
  }

  // ==========
  // Simulation helpers
  // ==========
  function simulateMove(baseState, dir){
    const snap = snapshotFromState(baseState);
    return simulateMoveFromSnapshot(snap, dir);
  }

  function snapshotFromState(st){
    return {
      N: st.N,
      board: st.board.map(r=>r.slice()),
      tilesById: JSON.parse(JSON.stringify(st.tilesById)),
    };
  }

  function simulateMoveFromSnapshot(snap, dir){
    const N = snap.N;

    // movement
    let movedAny = false;
    const boardNew = Array.from({length:N}, () => Array.from({length:N}, () => null));

    const tilesById = snap.tilesById;

    const updateTile = (id, nx, ny) => {
      const t = tilesById[id];
      if (t.x !== nx || t.y !== ny) movedAny = true;
      t.x = nx; t.y = ny;
      boardNew[ny][nx] = Number(id);
    };

    if (dir === "left" || dir === "right"){
      for (let y=0; y<N; y++){
        const line = [];
        for (let x=0; x<N; x++){
          const id = snap.board[y][x];
          if (id != null) line.push(id);
        }
        if (dir === "right") line.reverse();
        for (let i=0; i<line.length; i++){
          const id = line[i];
          const x = (dir === "left") ? i : (N-1-i);
          updateTile(id, x, y);
        }
      }
    } else {
      for (let x=0; x<N; x++){
        const line = [];
        for (let y=0; y<N; y++){
          const id = snap.board[y][x];
          if (id != null) line.push(id);
        }
        if (dir === "down") line.reverse();
        for (let i=0; i<line.length; i++){
          const id = line[i];
          const y = (dir === "up") ? i : (N-1-i);
          updateTile(id, x, y);
        }
      }
    }

    snap.board = boardNew;

    // breaks
    const {breakColorIds, idsToRemove} = computeBreaksForSnapshot(snap);
    const removedIds = [];

    if (idsToRemove.length){
      const idSet = new Set(idsToRemove.map(Number));
      for (const id of idSet){
        const t = snap.tilesById[id];
        if (!t) continue;
        snap.board[t.y][t.x] = null;
        delete snap.tilesById[id];
        removedIds.push(id);
      }
    }

    return {
      moved: movedAny,
      brokenCount: removedIds.length,
      breakColorIds,
      removedIds,
      snapshot: snap,
    };
  }

  function cloneHintSnapshot(snap){
    return {
      N: snap.N,
      board: snap.board.map(r => r.slice()),
      tilesById: JSON.parse(JSON.stringify(snap.tilesById)),
    };
  }

  // Come simulateMoveFromSnapshot, ma NON elimina i blocchi che “romperebbero”
  // (così possiamo animare lo scorrimento e poi dissolverli)
  function simulateMovePreviewFromSnapshot(snap, dir){
    const N = snap.N;

    let movedAny = false;
    const boardNew = Array.from({length:N}, () => Array.from({length:N}, () => null));
    const tilesById = snap.tilesById;

    const updateTile = (id, nx, ny) => {
      const t = tilesById[id];
      if (t.x !== nx || t.y !== ny) movedAny = true;
      t.x = nx; t.y = ny;
      boardNew[ny][nx] = Number(id);
    };

    if (dir === "left" || dir === "right"){
      for (let y=0; y<N; y++){
        const line = [];
        for (let x=0; x<N; x++){
          const id = snap.board[y][x];
          if (id != null) line.push(id);
        }
        if (dir === "right") line.reverse();
        for (let i=0; i<line.length; i++){
          const id = line[i];
          const x = (dir === "left") ? i : (N-1-i);
          updateTile(id, x, y);
        }
      }
    } else {
      for (let x=0; x<N; x++){
        const line = [];
        for (let y=0; y<N; y++){
          const id = snap.board[y][x];
          if (id != null) line.push(id);
        }
        if (dir === "down") line.reverse();
        for (let i=0; i<line.length; i++){
          const id = line[i];
          const y = (dir === "up") ? i : (N-1-i);
          updateTile(id, x, y);
        }
      }
    }

    snap.board = boardNew;

    // calcola cosa si romperebbe, ma NON cancellare
    const {breakColorIds, idsToRemove} = computeBreaksForSnapshot(snap);
    const removedIds = Array.from(new Set(idsToRemove.map(Number)));

    return {
      moved: movedAny,
      brokenCount: removedIds.length,
      breakColorIds,
      removedIds,
      snapshot: snap,
    };
  }

  function computeBreaksForSnapshot(snap){
    const tiles = Object.values(snap.tilesById);
    if (!tiles.length) return {breakColorIds:[], idsToRemove:[]};
    const byColor = new Map();
    for (const t of tiles){
      if (!byColor.has(t.colorId)) byColor.set(t.colorId, []);
      byColor.get(t.colorId).push(t);
    }
    const idsToRemove = [];
    const breakColorIds = [];
    for (const [colorId, list] of byColor.entries()){
      if (list.length < 2) continue;
      const target = new Set(list.map(t => key(t.x,t.y)));
      const visited = new Set();
      const q = [list[0]];
      visited.add(key(list[0].x, list[0].y));
      while (q.length){
        const cur = q.shift();
        for (const [nx,ny] of neighbors4(cur.x, cur.y, snap.N)){
          const k = key(nx,ny);
          if (visited.has(k)) continue;
          const id = snap.board[ny][nx];
          if (id == null) continue;
          const t = snap.tilesById[id];
          if (!t || t.colorId !== colorId) continue;
          visited.add(k);
          q.push(t);
        }
      }
      let allConnected = true;
      for (const pos of target){
        if (!visited.has(pos)) {allConnected=false; break;}
      }
      if (allConnected){
        breakColorIds.push(colorId);
        for (const t of list) idsToRemove.push(t.id);
      }
    }
    return {breakColorIds, idsToRemove};
  }

    // ==========
  // Solvability (PROVE impossibility only if reachable state-space is exhausted)
  // ==========
  function signatureForSnapshot(snap){
    const N = snap.N;
    let out = `${N}|`;
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        const id = snap.board[y][x];
        if (id == null) out += ".";
        else out += String(snap.tilesById[id].colorId);
        out += ",";
      }
      out += ";";
    }
    return out;
  }

  function cloneSnapshot(s){
    const tilesById = {};
    for (const idStr in s.tilesById){
      const t = s.tilesById[idStr];
      tilesById[idStr] = {id: t.id, colorId: t.colorId, x: t.x, y: t.y};
    }
    return {
      N: s.N,
      board: s.board.map(r => r.slice()),
      tilesById
    };
  }

  function analyzeSolvabilityForSnapshot(rootSnap, {timeBudgetMs=30, nodeLimit=3500}={}){
    const t0 = performance.now();
    const dirs = ["up","down","left","right"];

    const visited = new Set();
    visited.add(signatureForSnapshot(rootSnap));

    const q = [{snap: rootSnap, firstDir: null}];
    let expanded = 0;

    while (q.length){
      if (performance.now() - t0 > timeBudgetMs) {
        return {status:"unknown", firstDir:null, expanded, visited: visited.size};
      }
      if (expanded > nodeLimit) {
        return {status:"unknown", firstDir:null, expanded, visited: visited.size};
      }

      const cur = q.shift();
      expanded += 1;

      if (Object.keys(cur.snap.tilesById).length === 0){
        return {status:"solved", firstDir: cur.firstDir, expanded, visited: visited.size};
      }

      for (const dir of dirs){
        const next = cloneSnapshot(cur.snap);
        const sim = simulateMoveFromSnapshot(next, dir);

        const sig = signatureForSnapshot(sim.snapshot);
        if (visited.has(sig)) continue;
        visited.add(sig);

        q.push({
          snap: sim.snapshot,
          firstDir: cur.firstDir || dir,
        });
      }
    }

    // Exhausted => proven impossible
    return {status:"exhausted", firstDir:null, expanded, visited: visited.size};
  }

  function analyzeSolvabilityForSnapshotWithMoves(
    rootSnap,
    initialMoves,
    { timeBudgetMs = 140, nodeLimit = 180000 } = {}
  ){
    const t0 = performance.now();
    const dirs = ["up","down","left","right"];

    const startMoves = Math.max(0, (initialMoves|0));
    const root = cloneSnapshot(rootSnap);

    const totalTiles0 = Object.keys(root.tilesById).length;
    const movesCap = startMoves + Math.floor(totalTiles0 / 2); // upper bound safe
    const capMoves = (m) => Math.min(movesCap, Math.max(0, m|0));

    // Max-heap semplice (priority maggiore = prima)
    const heap = [];
    const heapPush = (node) => {
      heap.push(node);
      let i = heap.length - 1;
      while (i > 0){
        const p = ((i - 1) >> 1);
        if (heap[p].prio >= heap[i].prio) break;
        [heap[p], heap[i]] = [heap[i], heap[p]];
        i = p;
      }
    };
    const heapPop = () => {
      if (!heap.length) return null;
      const top = heap[0];
      const last = heap.pop();
      if (heap.length){
        heap[0] = last;
        let i = 0;
        for (;;){
          const l = i*2 + 1, r = l + 1;
          let best = i;
          if (l < heap.length && heap[l].prio > heap[best].prio) best = l;
          if (r < heap.length && heap[r].prio > heap[best].prio) best = r;
          if (best === i) break;
          [heap[i], heap[best]] = [heap[best], heap[i]];
          i = best;
        }
      }
      return top;
    };

    const sig0 = signatureForSnapshot(root);
    const bestMovesBySig = new Map();
    bestMovesBySig.set(sig0, startMoves);

    const tiles0 = Object.keys(root.tilesById).length;
    heapPush({
      snap: root,
      firstDir: null,
      movesLeft: startMoves,
      depth: 0,
      prio: (startMoves * 10) - tiles0
    });

    let expanded = 0;

    while (heap.length){
      if ((performance.now() - t0) > timeBudgetMs){
        return { status:"unknown", firstDir:null, expanded, visited: bestMovesBySig.size };
      }
      if (expanded >= nodeLimit){
        return { status:"unknown", firstDir:null, expanded, visited: bestMovesBySig.size };
      }

      const cur = heapPop();
      expanded++;

      const remaining = Object.keys(cur.snap.tilesById).length;
      if (remaining === 0){
        return {
          status: "solved",
          firstDir: cur.firstDir,
          depth: cur.depth,
          expanded,
          visited: bestMovesBySig.size
        };
      }

      for (const dir of dirs){
        // clona e simula
        const nextSnap = cloneSnapshot(cur.snap);
        const sim = simulateMoveFromSnapshot(nextSnap, dir);

        // Se non si muove nulla, in gioco NON consumi mosse e NON rompi: trattiamo come "skip"
        if (!sim.moved) continue;

        const gained = Math.floor(sim.brokenCount / 2);
        let nextMoves = cur.movesLeft - 1 + gained;
        if (nextMoves < 0) continue;
        nextMoves = capMoves(nextMoves);

        const sig = signatureForSnapshot(sim.snapshot);
        const prevBest = bestMovesBySig.get(sig);
        if (prevBest != null && prevBest >= nextMoves) continue;
        bestMovesBySig.set(sig, nextMoves);

        const tilesLeft = Object.keys(sim.snapshot.tilesById).length;
        heapPush({
          snap: sim.snapshot,
          firstDir: cur.firstDir || dir,
          movesLeft: nextMoves,
          depth: cur.depth + 1,
          prio: (nextMoves * 10) - tilesLeft
        });
      }
    }

    // Se esaurisci davvero l'heap senza time/node limit => impossibile entro quelle mosse (provato)
    return { status:"exhausted", firstDir:null, expanded, visited: bestMovesBySig.size };
  }


  function analyzeSolvabilityCurrentState(opts){
    const snap = snapshotFromState(state);
    return analyzeSolvabilityForSnapshotWithMoves(snap, state.moves|0, opts);
  }


  // ==========
  // Utils
  // ==========
  function neighbors4(x,y,N){
    const out = [];
    if (x>0) out.push([x-1,y]);
    if (x<N-1) out.push([x+1,y]);
    if (y>0) out.push([x,y-1]);
    if (y<N-1) out.push([x,y+1]);
    return out;
  }

  function key(x,y){ return `${x},${y}`; }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function randInt(a,b){
    // inclusive
    const r = Math.random();
    return a + Math.floor(r * (b-a+1));
  }

  // ===== Haptics (mobile) =====
  function haptic(pattern){
    try{
      if (!navigator.vibrate) return;
      if (localStorage.getItem("haptics_off") === "1") return;
      navigator.vibrate(pattern);
    } catch (_) {}
  }

  const HAPTIC_BREAK = [10];
  const HAPTIC_ERROR = [20, 30, 20];

  function isHapticsOn(){
    return localStorage.getItem("haptics_off") !== "1";
  }

  function syncHapticsButton(){
    const btn = document.getElementById("btnHaptics");
    if (!btn) return;
    const key = isHapticsOn() ? "btn.haptics_on" : "btn.haptics_off";
    btn.setAttribute("data-i18n", key);

    // aggiorna il testo subito anche se applyI18n non c’è
    if (typeof t === "function") btn.textContent = t(key);
  }


  function toggleHaptics(){
    const off = localStorage.getItem("haptics_off") === "1";
    localStorage.setItem("haptics_off", off ? "0" : "1");
    syncHapticsButton();
    if (!off) haptic([10]); // preview quando attivi
  }

  function randFloat(a,b){
    return a + Math.random()*(b-a);
  }

  function shuffle(arr){
    for (let i=arr.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
  function nextFrame(){ return new Promise(res => requestAnimationFrame(() => res())); }

  const elLevelLoading = document.getElementById("levelLoading");
  const elLevelLoadingText = document.getElementById("levelLoadingText");

  function showLevelLoading(msg){
    if (!elLevelLoading) return;
    if (elLevelLoadingText) elLevelLoadingText.textContent = msg || "Loading…";
    elLevelLoading.classList.remove("hidden");
    elLevelLoading.setAttribute("aria-hidden", "false");
  }

  function hideLevelLoading(){
    if (!elLevelLoading) return;
    elLevelLoading.classList.add("hidden");
    elLevelLoading.setAttribute("aria-hidden", "true");
  }
  window.showLevelLoading = showLevelLoading;
  window.hideLevelLoading = hideLevelLoading;


  function waitTransitions(elements, timeoutMs = 600) {
    return new Promise((resolve) => {
      const els = elements.filter(Boolean);
      if (!els.length) return resolve();

      let done = 0;
      let settled = false;

      const finish = () => {
        if (settled) return;
        settled = true;
        cleanup();
        resolve();
      };

      const onEnd = (e) => {
        // ci interessa soprattutto transform (lo scorrimento)
        if (e.propertyName !== "transform") return;
        done += 1;
        if (done >= els.length) finish();
      };

      const cleanup = () => {
        for (const el of els) el.removeEventListener("transitionend", onEnd);
        clearTimeout(tid);
      };

      for (const el of els) el.addEventListener("transitionend", onEnd, { passive: true });

      // fallback safety: non rimanere mai bloccato
      const tid = setTimeout(finish, timeoutMs);
    });
  }


  function getCssVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function toastMsg(msg){
    const now = Date.now();
    if (now - lastToastAt < 120) return;
    lastToastAt = now;
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(() => toast.classList.remove("show"), 1300);
  }


  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // se hai un flag tipo `animating` / `isAnimating` / `busy`, usa quello.
  // altrimenti puoi “aspettare” finché non finisce la mossa.
  async function waitNotBusy(){
    while (isAnimating) await sleep(16);
  }



  function pulseUndoButton() {
    const btn = document.getElementById("btnUndo");
    if (!btn) return;
    btn.classList.add("undo-pulse");
  }

  function stopPulseUndoButton() {
    const btn = document.getElementById("btnUndo");
    if (!btn) return;
    btn.classList.remove("undo-pulse");
  }

  
  function enterAutoTutorial(){
    // salva partita reale (per ripristinare dopo)
    autoReturnSnapshot = deepCopy(state);

    // tutorial sempre da zero
    state = newGameState();

    // genera subito il livello 1 (IMPORTANTE: AUTO_MODE deve già essere true,
    // così startLevel non salva su storage)
    void startLevel(1);
  }

  function exitAutoTutorial({silent=false} = {}){
    // spegne e ripristina
    AUTO_MODE = false;
    applyFxSpeed();
    autoStop = true;

    const btnAuto = document.getElementById("btnAuto");
    if (btnAuto) btnAuto.classList.remove("active");

    if (autoReturnSnapshot){
      state = autoReturnSnapshot;
      autoReturnSnapshot = null;

      stalloShown = false;
      stopPulseUndoButton();

      renderAll(true);
      saveNow(); // salva solo la partita vera (AUTO_MODE ora è false)
    }

    if (!silent) toastMsg("AUTO: OFF");
  }


  function showStalloMessage() {
    if (stalloShown) return;
    stalloShown = true;

    const el = document.getElementById("stalloMsg");
    if (!el) return;

    el.classList.remove("hidden");

    setTimeout(() => {
      el.classList.add("hidden");
    }, 1200);
  }


  let lastBigToastAt = 0;
  function bigToast(msg, ms=1100){
    const now = Date.now();
    if (now - lastBigToastAt < 250) return;
    lastBigToastAt = now;
    toast.textContent = msg;
    toast.classList.add("big");
    toast.classList.add("show");
    setTimeout(() => {
      toast.classList.remove("show");
      // remove big after transition to avoid layout pop
      setTimeout(() => toast.classList.remove("big"), 180);
    }, ms);
  }

  function dirToArrow(dir){
    if (dir === "up") return "↑";
    if (dir === "down") return "↓";
    if (dir === "left") return "←";
    return "→";
  }


  async function pickBestDirAuto(){
    // 1) prova il percorso "fast" se ce l’hai (hint normale)
    try{
      if (typeof computeHintDirectionForCurrentState === "function"){
        const d = computeHintDirectionForCurrentState();
        if (d) return { dir: d, mode: "fast" };
      }
    }catch(_){}

    // 2) deep calc (usa il solver che ESISTE già nel file)
    // Aumentiamo budget per AUTO, così trova davvero una strada.
    try{
      if (typeof analyzeSolvabilityCurrentState === "function"){
        const solv = analyzeSolvabilityCurrentState({
          timeBudgetMs: 220,   // puoi alzare a 400 se vuoi più “certezza”
          nodeLimit: 20000     // puoi alzare, ma occhio ai freeze
        });

        const d =
          solv?.bestFirstDir ||
          solv?.firstDir ||
          (Array.isArray(solv?.path) ? solv.path[0] : null) ||
          null;

        if (d) return { dir: d, mode: "deep", status: solv?.status || "unknown" };

        return { dir: null, mode: "deep", status: solv?.status || "unknown" };
      }
    }catch(_){}

  }

  // ==========
  // SVGs
  // ==========
  function svgWrap(inner){
    return `<svg viewBox="0 0 100 100" aria-hidden="true" focusable="false">${inner}</svg>`;
  }

  function svgX(){
    return svgWrap(`<line x1="20" y1="20" x2="80" y2="80" stroke="rgba(255,255,255,.92)" stroke-width="12" stroke-linecap="round"/>
                    <line x1="80" y1="20" x2="20" y2="80" stroke="rgba(255,255,255,.92)" stroke-width="12" stroke-linecap="round"/>`);
  }

  function svgInnerSquare(){
    return svgWrap(`<rect x="22" y="22" width="56" height="56" rx="10" ry="10" fill="none" stroke="rgba(255,255,255,.92)" stroke-width="12"/>`);
  }

  function svgCircle(){
    return svgWrap(`<circle cx="50" cy="50" r="28" fill="none" stroke="rgba(255,255,255,.92)" stroke-width="12"/>`);
  }

  function svgTriangle(){
    return svgWrap(`<path d="M50 18 L82 78 H18 Z" fill="none" stroke="rgba(255,255,255,.92)" stroke-width="12" stroke-linejoin="round"/>`);
  }

  function svgEquals(){
    return svgWrap(`<line x1="22" y1="40" x2="78" y2="40" stroke="rgba(255,255,255,.92)" stroke-width="12" stroke-linecap="round"/>
                    <line x1="22" y1="60" x2="78" y2="60" stroke="rgba(255,255,255,.92)" stroke-width="12" stroke-linecap="round"/>`);
  }

  function svgStar5(){
    // 5-point star path
    return svgWrap(`<path d="M50 16 L61 39 L86 42 L67 58 L72 83 L50 70 L28 83 L33 58 L14 42 L39 39 Z"
                     fill="none" stroke="rgba(255,255,255,.92)" stroke-width="10" stroke-linejoin="round"/>`);
  }

  function svgPaw(){
    // stylized paw: 4 toes + pad
    return svgWrap(`
      <circle cx="30" cy="34" r="8"/>
      <circle cx="50" cy="26" r="8"/>
      <circle cx="70" cy="34" r="8"/>
      <circle cx="60" cy="50" r="7"/>
      <path d="M28 64 C28 52, 40 46, 50 50 C60 46, 72 52, 72 64 C72 76, 60 84, 50 84 C40 84, 28 76, 28 64 Z"/>
    `);
  }

  function starSVG(){
    return `<svg viewBox="0 0 100 100" width="10" height="10" aria-hidden="true">
      <path d="M50 10 L60 38 L90 40 L66 58 L74 88 L50 72 L26 88 L34 58 L10 40 L40 38 Z" fill="rgba(255,255,255,.96)"/>
    </svg>`;
  }
  // ==========
  // NOTE: l'inizializzazione partita è gestita da init() / startGame().
  // Non auto-renderizzare qui: se state è ancora null (prima del login), può causare crash.
  // ==========
})();
</script>
<div id="rewardOverlay" class="reward-overlay hidden" role="dialog" aria-modal="true">
  <div class="reward-card">
    <div class="reward-title" data-i18n="Ads1">Hai finito gli hint</div>
    <div class="reward-text" data-i18n="Ads2">Guarda una pubblicità (pochi secondi) e ottieni <b>+2 hint</b>.</div>
    <div class="reward-actions">
      <button id="btnRewardWatch" class="btn">Guarda</button>
      <button id="btnRewardCancel" class="btn secondary">Annulla</button>
    </div>
    <div id="rewardStatus" class="small" style="margin-top:8px; opacity:.85;"></div>
  </div>
</div>


</div>

<script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("/sw.js")
      .catch(err => console.log("SW registration failed:", err));
  }
</script>



  <!-- Offline overlay -->
  <div id="offlineOverlay" class="offline-overlay hidden" role="dialog" aria-modal="true">
    <div class="offline-card">
      <div class="offline-title">Nessuna connessione</div>
      <div class="offline-text">Sembra che tu sia offline. Riconnettiti e premi <b>Refresh</b>.</div>
      <div class="offline-actions">
        <button id="btnOfflineRefresh" class="btn">Refresh</button>
      </div>
    </div>
  </div>


  <script>
document.addEventListener("DOMContentLoaded", function () {
  const rewardOverlay   = document.getElementById("rewardOverlay");
  const btnReward2Hints = document.getElementById("btnReward2Hints");
  const btnRewardWatch  = document.getElementById("btnRewardWatch");
  const btnRewardCancel = document.getElementById("btnRewardCancel");
  const rewardStatusEl  = document.getElementById("rewardStatus");

  if (!rewardOverlay || !btnReward2Hints || !btnRewardWatch || !btnRewardCancel) return;

  // evita doppi listener se lo script viene incluso 2 volte o init riattacca
  if (btnReward2Hints.dataset.boundReward === "1") return;
  btnReward2Hints.dataset.boundReward = "1";

  const setStatus = (txt) => { if (rewardStatusEl) rewardStatusEl.textContent = txt || ""; };

  function openReward(){
    rewardOverlay.classList.remove("hidden");
    rewardOverlay.setAttribute("aria-hidden","false");
    setStatus("");
  }

  function closeReward(){
    rewardOverlay.classList.add("hidden");
    rewardOverlay.setAttribute("aria-hidden","true");
    setStatus("");
  }

  btnReward2Hints.addEventListener("click", openReward);
  btnRewardCancel.addEventListener("click", closeReward);

  btnRewardWatch.addEventListener("click", async () => {
    setStatus("Caricamento…");

    if (!window.Ads || typeof Ads.showRewardedFor2Hints !== "function") {
      setStatus("Pubblicità non disponibile.");
      return;
    }

    btnRewardWatch.disabled = true;
    try{
      const r = await Ads.showRewardedFor2Hints();
      if (r && r.ok && r.rewarded){
        if (typeof onRewardedAdCompleted === "function") onRewardedAdCompleted();
        closeReward();
      } else {
        setStatus("Pubblicità non disponibile.");
      }
    } catch(e){
      setStatus("Errore.");
      console.warn("Rewarded ad error:", e);
    } finally {
      btnRewardWatch.disabled = false;
    }
  });
});
</script>


<div id="uiDialogOverlay" class="modal-overlay" aria-hidden="true">
  <div class="modal" style="max-width:520px;">
    <header>
      <h2 id="uiDialogTitle">Converge</h2>
      <button id="uiDialogX" class="btn secondary">✕</button>
    </header>
    <div class="content">
      <div id="uiDialogMsg" style="opacity:.92; line-height:1.35;"></div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:14px;">
        <button id="uiDialogCancel" class="btn secondary">Annulla</button>
        <button id="uiDialogOk" class="btn">OK</button>
      </div>
    </div>
  </div>
</div>

<!-- PRIVACY OVERLAY -->
<div id="privacyOverlay" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-label="Privacy Policy">
  <div class="modal" style="width:min(820px, 96vw); height:min(80vh, 760px); display:flex; flex-direction:column;">
    <header>
      <h2>Privacy Policy</h2>
      <button id="btnClosePrivacy" type="button" aria-label="Close" title="Close">✕</button>
    </header>

    <div class="content" style="padding:0; flex:1; min-height: 50vh;">
      <iframe
        id="privacyFrame"
        src="privacy.html"
        style="border:0; width:100%; height:100%; border-radius: 0 0 26px 26px;"
        title="Privacy Policy"
      ></iframe>
    </div>
  </div>
</div>

</body>
</html>